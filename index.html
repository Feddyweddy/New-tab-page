<!DOCTYPE html>
<html>

<head>
  <link rel="stylesheet" href="style.css" />
  <script>
    // ===== CONFIGURATION =====
    // Change this to use a different links file (e.g., 'links-work.json', 'links-gaming.json')
    const LINKS_FILENAME = 'links-private.json';
    const DEFAULT_BACKGROUND_URL = 'url("https://i.imgur.com/yXXStJ4.jpeg") no-repeat center center fixed;';
    // =========================
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
  <meta charset="utf-8" />
  <title>Links</title>
</head>
<body>
  <div class="background-overlay"></div>
  <div class="burger-menu">
    <button class="burger-button" onclick="toggleMenu()">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div class="menu-content">
      <div class="menu-section">
        <button class="menu-button" id="toggleHiddenButton" onclick="toggleAllHidden()">Show all</button>
        <button class="menu-button" onclick="toggleMode()">Toggle theme</button>
        <button class="menu-button" onclick="toggleEditMode()">Edit shortcuts</button>
      </div>
      <hr class="hr">
      <!-- Layout options -->
      <div class="menu-section collapsible">
        <button class="menu-section-header" onclick="toggleSection(this)">Layout options</button>
        <div class="menu-section-content">
          <div class="menu-slider-group">
            <label>Shortcut size: <span id="shortcutSizeValue">124</span>px</label>
            <input type="range" id="shortcutSizeSlider" min="64" max="192" value="124" class="menu-slider">
          </div>
          <div class="menu-slider-group">
            <label>Gap size: <span id="gapSizeValue">10</span>px</label>
            <input type="range" id="gapSizeSlider" min="5" max="124" value="10" class="menu-slider">
          </div>
          <div class="menu-slider-group">
            <label>Glow: <span id="shadowValue">3</span>px</label>
            <input type="range" id="shadowSlider" min="3" max="15" value="3" class="menu-slider">
          </div>
          <div class="menu-input-group">
            <label>Max columns:</label>
            <span><select id="maxColumnsSelect" class="menu-input">
                <option value="unlimited">Unlimited</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
              </select></span>
          </div>
          <button id="autoFitEnabled" class="menu-button" onclick="toggleAutoFit()">Auto fit</button>
        </div>
      </div>
      <hr class="hr">
      <!-- Background -->
      <div class="menu-section collapsible">
        <button class="menu-section-header" onclick="toggleSection(this)">Background</button>
        <div class="menu-section-content">
          <div class="menu-input-group">
            <input type="text" id="bgUrlInput" placeholder="Image URL" class="menu-input" style="width: 100%">
            <button class="menu-button small" onclick="setBackgroundFromUrl()">Set</button>
          </div>
          <div class="menu-input-group">
            <input type="file" id="bgFileInput" accept="image/*" class="menu-input" style="display: none">
            <button class="menu-button" onclick="document.getElementById('bgFileInput').click()">Upload Image</button>
          </div>
          <div class="menu-slider-group">
            <label>Blur: <span id="blurValue">0</span>px</label>
            <input type="range" id="blurSlider" min="0" max="20" value="0" class="menu-slider">
          </div>
          <div class="menu-slider-group">
            <label>Brightness: <span id="brightnessValue">100</span></label>
            <input type="range" id="brightnessSlider" min="1" max="100" value="100" class="menu-slider">
          </div>
          <div class="menu-slider-group">
            <label>Contrast: <span id="contrastValue">1.0</span></label>
            <input type="range" id="contrastSlider" min="1" max="200" value="100" class="menu-slider">
          </div>
        </div>
      </div>
      <hr class="hr">
      <!-- Backup / Restore -->
      <div class="menu-section collapsible">
        <button class="menu-section-header" onclick="toggleSection(this)">Backup / Restore</button>
        <div class="menu-section-content">
          <a href="#" class="menu-button" onclick="requestStoragePermission(event)">
            Persist settings
          </a>
          <button class="menu-button" onclick="exportConfig()">Export config</button>
          <button class="menu-button" onclick="importConfig()">Import config</button>
        </div>
      </div>
    </div>
  </div>
  <div id="editModal" class="modal">
    <div class="modal-content">
      <h3 id="modalTitle">Add Shortcut</h3>
      <div id="urlInputSection">
        <input type="text" id="editUrl" placeholder="Enter website URL (e.g., https://youtube.com)">
        <div id="fetchingIndicator" style="display: none; color: #666; margin: 5px 0;">
          Fetching site information...
        </div>
      </div>
      <div id="detailsSection" style="display: none;">
        <input type="text" id="editTitle" placeholder="Title">
        <input type="text" id="editImage" placeholder="Image URL">
        <div class="modal-checkbox-container">
          <input type="checkbox" id="editHidden">
          <label for="editHidden">Hide in collapsed view</label>
        </div>
      </div>
      <div class="modal-buttons">
        <button onclick="closeModal()">Cancel</button>
        <button id="fetchButton" onclick="fetchSiteInfo()" style="display: none;">Fetch Info</button>
        <button id="saveButton" onclick="saveShortcut()" style="display: none;">Save</button>
      </div>
    </div>
  </div>
  <div id="container"></div>
  <script>
    let editMode = false;
    let currentEditingShortcut = null;
    let currentEditingSectionName = null;

    // Auto-fit state management
let autoFitEnabled = false;

function toggleAutoFit() {
    const autoFitButton = document.getElementById('autoFitEnabled');
    autoFitEnabled = !autoFitEnabled;
    
    if (autoFitEnabled) {
        // Enable auto-fit: adjust sizes based on viewport
        autoAdjustShortcutSize();
        autoFitButton.textContent = 'Reset sizes';
    } else {
        // Disable auto-fit: reset to default hardcoded values
        const shortcutSizeSlider = document.getElementById('shortcutSizeSlider');
        const gapSizeSlider = document.getElementById('gapSizeSlider');
        
        shortcutSizeSlider.value = 124;
        gapSizeSlider.value = 10;
        
        document.getElementById('shortcutSizeValue').textContent = 124;
        document.getElementById('gapSizeValue').textContent = 10;
        
        updateShortcutStyles();
        autoFitButton.textContent = 'Auto fit';
    }
    
    if (localStorage.getItem('persistSettings') === 'true') {
        saveConfig();
    }
}

    function toggleSection(header) {
      const content = header.nextElementSibling;
      // Check computed style to correctly determine visibility, even if set by CSS
      if (window.getComputedStyle(content).display === 'none') {
        content.style.display = 'block';
      } else {
        content.style.display = 'none';
      }
      header.classList.toggle('active');
    }

    function toggleEditMode() {
      editMode = !editMode;
      document.body.classList.toggle('edit-mode');
      refreshUI();
    }

    function refreshUI() {
      const container = document.getElementById('container');
      container.innerHTML = '';
      loadLinks();
    }

    async function loadLinks() {
  let data;
  try {
    console.log(`Attempting to load ${LINKS_FILENAME}...`);
    const response = await fetch(LINKS_FILENAME);
    console.log('Response status:', response.status, response.statusText);
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    data = await response.json();
    console.log(`Successfully loaded ${LINKS_FILENAME} with`, Object.keys(data).length, 'sections');
  } catch (error) {
    console.error(`Could not load ${LINKS_FILENAME}:`, error);
    alert(`Could not load your shortcuts from ${LINKS_FILENAME}. Make sure you're accessing the page through a web server (e.g., http://localhost:8000)`);
    return;
  }
  const container = document.getElementById('container');
  
  console.log('Rendering sections:', Object.keys(data));
  console.log('Total sections to render:', Object.keys(data).length);

  Object.entries(data).forEach(([sectionName, links]) => {
    console.log(`Rendering section: ${sectionName} with ${links.length} shortcuts`);
    // Create a section wrapper
    const sectionWrapper = document.createElement('div');
    sectionWrapper.className = 'section-wrapper';
    sectionWrapper.style.cssText = 'display: flex; flex-direction: column; flex: 0 1 auto;';

    const sectionTitle = document.createElement('h2');
    sectionTitle.className = 'section-title';
    sectionTitle.textContent = sectionName;
    sectionWrapper.appendChild(sectionTitle);

    const row = document.createElement('div');
    row.className = 'section-row';
    row.setAttribute('data-section', sectionName);

    if (editMode) {
      // In edit mode, render ALL shortcuts (hidden and visible) in the main row
      links.forEach((item, index) => {
        // Create wrapper for shortcut and buttons
        const shortcutWrapper = document.createElement('div');
        shortcutWrapper.className = 'shortcut-wrapper';
        
        const shortDiv = document.createElement('a');
        shortDiv.href = 'javascript:void(0)';
        shortDiv.className = 'shortcut';
        shortDiv.style.setProperty('--shortcut-background', `url('${item.image}')`);
        shortDiv.setAttribute('title', item.title);
        shortDiv.setAttribute('draggable', 'true');
        shortDiv.setAttribute('data-index', index);

        // Add drag and drop event listeners
        shortDiv.addEventListener('dragstart', handleDragStart);
        shortDiv.addEventListener('dragend', handleDragEnd);
        shortDiv.addEventListener('dragover', handleDragOver);
        shortDiv.addEventListener('dragenter', handleDragEnter);
        shortDiv.addEventListener('dragleave', handleDragLeave);
        shortDiv.addEventListener('drop', handleDrop);

        shortDiv.innerHTML = `
          <img src="${item.image}" class="shortcutimg" alt="${item.title}" />
          <div class="title">${item.title}</div>
        `;
        
        shortcutWrapper.appendChild(shortDiv);

        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'shortcut-buttons';
        buttonsDiv.innerHTML = `
          <div class="edit-shortcut" onclick="editShortcut(this)">EDIT</div>
          <div class="delete-shortcut" onclick="deleteShortcut(this)">×</div>
        `;
        shortcutWrapper.appendChild(buttonsDiv);
        
        row.appendChild(shortcutWrapper);
      });
    } else {
      // In normal mode, render visible shortcuts first
      links.forEach((item, index) => {
        // Skip hidden shortcuts - they'll be handled separately
        if (item.hidden) return;
        
        // Create wrapper for shortcut and buttons
        const shortcutWrapper = document.createElement('div');
        shortcutWrapper.className = 'shortcut-wrapper';
        
        const shortDiv = document.createElement('a');
        shortDiv.href = item.url;
        shortDiv.className = 'shortcut';
        shortDiv.style.setProperty('--shortcut-background', `url('${item.image}')`);
        shortDiv.setAttribute('title', item.title);
        shortDiv.setAttribute('draggable', 'true');
        shortDiv.setAttribute('data-index', index);

        // Add drag and drop event listeners
        shortDiv.addEventListener('dragstart', handleDragStart);
        shortDiv.addEventListener('dragend', handleDragEnd);
        shortDiv.addEventListener('dragover', handleDragOver);
        shortDiv.addEventListener('dragenter', handleDragEnter);
        shortDiv.addEventListener('dragleave', handleDragLeave);
        shortDiv.addEventListener('drop', handleDrop);

        shortDiv.innerHTML = `
          <img src="${item.image}" class="shortcutimg" alt="${item.title}" />
          <div class="title">${item.title}</div>
        `;
        
        shortcutWrapper.appendChild(shortDiv);
        row.appendChild(shortcutWrapper);
      });

      // Check if there are hidden shortcuts
      const hiddenShortcuts = links.filter(item => item.hidden);
      if (hiddenShortcuts.length > 0) {
        // Create hidden shortcuts container for inline expansion
        const hiddenContainer = document.createElement('div');
        hiddenContainer.className = 'hidden-shortcuts-container';
        
        hiddenShortcuts.forEach((item, index) => {
          // Create wrapper for hidden shortcut and buttons
          const hiddenWrapper = document.createElement('div');
          hiddenWrapper.className = 'shortcut-wrapper';
          
          const hiddenShortcut = document.createElement('a');
          hiddenShortcut.href = item.url;
          hiddenShortcut.target = '_blank';
          hiddenShortcut.className = 'hidden-shortcut';
          hiddenShortcut.style.setProperty('--shortcut-background', `url("${item.image}")`);
          hiddenShortcut.setAttribute('title', item.title);
          hiddenShortcut.setAttribute('draggable', 'true');
          // Find the actual index in the original links array for hidden shortcuts
          const actualIndex = links.findIndex(link => link === item);
          hiddenShortcut.setAttribute('data-index', actualIndex);
          
          hiddenShortcut.innerHTML = `
            <img src="${item.image}" alt="${item.title}" class="shortcutimg" />
            <div class="title">${item.title}</div>
          `;
          
          hiddenWrapper.appendChild(hiddenShortcut);
          hiddenContainer.appendChild(hiddenWrapper);
        });
        
        // Create chevron button
        const chevronButton = document.createElement('div');
        chevronButton.className = 'chevron-button';
        chevronButton.innerHTML = '<span class="chevron-icon"></span>';
        chevronButton.setAttribute('role', 'button');
        chevronButton.setAttribute('tabindex', '0');
        chevronButton.setAttribute('aria-expanded', 'false');
        chevronButton.setAttribute('aria-label', 'Show hidden shortcuts');
        
        chevronButton.addEventListener('click', () => {
          const isExpanded = chevronButton.classList.contains('expanded');
          
          if (isExpanded) {
            // Collapsing: remove expanded class first to trigger exit animation
            hiddenContainer.classList.remove('expanded');
            chevronButton.classList.remove('expanded');
            
            // After animation completes, update aria attributes
            setTimeout(() => {
              chevronButton.setAttribute('aria-expanded', 'false');
              chevronButton.setAttribute('aria-label', 'Show hidden shortcuts');
            }, 400); // Match the transition duration
          } else {
            // Expanding: add expanded class to trigger enter animation
            chevronButton.classList.add('expanded');
            hiddenContainer.classList.add('expanded');
            chevronButton.setAttribute('aria-expanded', 'true');
            chevronButton.setAttribute('aria-label', 'Hide hidden shortcuts');
          }
          
          // Update the toggle all button text based on current state
          updateToggleAllButtonText();
        });

        // Add hidden container and chevron to row
        row.appendChild(hiddenContainer);
        row.appendChild(chevronButton);
      }
    }

    if (editMode) {
      const addButton = document.createElement('div');
      addButton.className = 'add-shortcut';
      addButton.innerHTML = '+';
      addButton.onclick = () => addShortcut(sectionName);
      row.appendChild(addButton);
    }

    sectionWrapper.appendChild(row);
    container.appendChild(sectionWrapper);
  });

  // Initialize UI values after all elements are created
  setTimeout(() => {
    initializeUIValues();
  }, 100); // Small delay to ensure all styles are computed
}

function updateToggleAllButtonText() {
      const toggleButton = document.getElementById('toggleHiddenButton');
      if (!toggleButton) return;
      
      const hiddenContainers = document.querySelectorAll('.hidden-shortcuts-container');
      if (hiddenContainers.length === 0) {
        toggleButton.textContent = 'Show all hidden';
        return;
      }
      
      const anyExpanded = Array.from(hiddenContainers).some(container => 
        container.classList.contains('expanded')
      );
      
      const allExpanded = Array.from(hiddenContainers).every(container => 
        container.classList.contains('expanded')
      );
      
      if (allExpanded) {
        toggleButton.textContent = 'Hide all hidden';
      } else if (anyExpanded) {
        toggleButton.textContent = 'Show all hidden';
      } else {
        toggleButton.textContent = 'Show all hidden';
      }
    }

    function toggleAllHidden() {
      const hiddenContainers = document.querySelectorAll('.hidden-shortcuts-container');
      const chevronButtons = document.querySelectorAll('.chevron-button');
      
      if (hiddenContainers.length === 0) return;
      
      // Check if all are currently expanded
      const allExpanded = Array.from(hiddenContainers).every(container => 
        container.classList.contains('expanded')
      );
      
      // Toggle all containers and chevron buttons with staggered timing
      hiddenContainers.forEach((container, index) => {
        const chevronButton = chevronButtons[index];
        
        // Add a small delay between each section for a wave effect
        setTimeout(() => {
          if (allExpanded) {
            // Hide all
            container.classList.remove('expanded');
            if (chevronButton) {
              chevronButton.classList.remove('expanded');
              // Update aria attributes after animation completes
              setTimeout(() => {
                chevronButton.setAttribute('aria-expanded', 'false');
                chevronButton.setAttribute('aria-label', 'Show hidden shortcuts');
              }, 400);
            }
          } else {
            // Show all
            container.classList.add('expanded');
            if (chevronButton) {
              chevronButton.classList.add('expanded');
              chevronButton.setAttribute('aria-expanded', 'true');
              chevronButton.setAttribute('aria-label', 'Hide hidden shortcuts');
            }
          }
        }, index * 100); // Stagger by 100ms for each section
      });
      
      // Update the toggle button text after all animations complete
      setTimeout(() => {
        updateToggleAllButtonText();
      }, (hiddenContainers.length * 100) + 400);
    }

    function toggleMode() {
      document.body.classList.toggle('dark-mode');
      
      // Save the theme preference if persist settings is enabled
      if (localStorage.getItem('persistSettings') === 'true') {
        saveConfig();
      }
    }
    // Add these functions after the loadLinks function
    let draggedElement = null;

    function handleDragStart(e) {
      if (!editMode) return;
      
      draggedElement = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', this.getAttribute('data-index'));
    }

    function handleDragEnd(e) {
      if (!editMode) return;
      
      this.classList.remove('dragging');
      const sections = document.querySelectorAll('.section-row');
      sections.forEach(section => {
        section.classList.remove('drag-active');
      });
    }

    function handleDragOver(e) {
      if (!editMode) return;
      
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }

    function handleDragEnter(e) {
      if (!editMode) return;
      
      e.preventDefault();
      this.classList.add('drag-over');
      this.closest('.section-row').classList.add('drag-active');
    }

    function handleDragLeave(e) {
      if (!editMode) return;
      
      this.classList.remove('drag-over');
    }

    function handleDrop(e) {
      if (!editMode) return;
      
      e.preventDefault();
      this.classList.remove('drag-over');
      
      const sourceIndex = parseInt(e.dataTransfer.getData('text/plain'));
      const targetIndex = parseInt(this.getAttribute('data-index'));
      
      if (sourceIndex === targetIndex) return;
      
      const sourceSection = draggedElement.closest('.section-row').getAttribute('data-section');
      const targetSection = this.closest('.section-row').getAttribute('data-section');
      
      reorderShortcuts(sourceSection, targetSection, sourceIndex, targetIndex);
    }

    async function reorderShortcuts(sourceSection, targetSection, sourceIndex, targetIndex) {
      try {
        const response = await fetch(LINKS_FILENAME);
        if (!response.ok) throw new Error('Failed to fetch');
        const data = await response.json();
        
        // Get the shortcut to move
        const shortcut = data[sourceSection][sourceIndex];
        
        // Remove from source
        data[sourceSection].splice(sourceIndex, 1);
        
        // Add to target
        if (sourceSection === targetSection) {
          data[targetSection].splice(targetIndex, 0, shortcut);
        } else {
          data[targetSection].splice(targetIndex, 0, shortcut);
        }
        
        // Save the updated data (this will likely fail in file:// mode)
        try {
          await fetch(LINKS_FILENAME, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data, null, 2)
          });
        } catch (saveError) {
          console.warn(`Could not save changes to ${LINKS_FILENAME} (expected in file:// mode):`, saveError);
        }
        
        // Refresh the UI
        refreshUI();
      } catch (error) {
        console.error('Error updating shortcuts:', error);
        alert('Could not reorder shortcuts. This feature requires a web server.');
      }
    }

    function deleteShortcut(button) {
      const shortcutWrapper = button.closest('.shortcut-wrapper');
      const row = shortcutWrapper.parentElement;
      shortcutWrapper.remove();
      saveChanges();
    }

    function editShortcut(button) {
    const shortcutWrapper = button.closest('.shortcut-wrapper');
    const shortcut = shortcutWrapper.querySelector('.shortcut, .hidden-shortcut');
    currentEditingShortcut = shortcut;
    const modal = document.getElementById('editModal');
    const titleInput = document.getElementById('editTitle');
    const urlInput = document.getElementById('editUrl');
    const imageInput = document.getElementById('editImage');
    const hiddenInput = document.getElementById('editHidden');

    // Set modal title for editing
    document.getElementById('modalTitle').textContent = 'Edit Shortcut';
    
    // Show URL section with fetch button for editing
    document.getElementById('urlInputSection').style.display = 'block';
    document.getElementById('detailsSection').style.display = 'block';
    document.getElementById('fetchButton').style.display = 'inline-block';
    document.getElementById('saveButton').style.display = 'inline-block';

    titleInput.value = currentEditingShortcut.querySelector('.title').textContent;
    urlInput.value = currentEditingShortcut.href;
    imageInput.value = currentEditingShortcut.querySelector('.shortcutimg').src;
    
    // Check if this shortcut is marked as hidden in the data
    const sectionName = currentEditingShortcut.closest('.section-row').getAttribute('data-section');
    const shortcutIndex = parseInt(currentEditingShortcut.getAttribute('data-index'));
    
    // We'll need to fetch the current data to check hidden status
    fetch(LINKS_FILENAME)
        .then(response => {
            if (!response.ok) throw new Error('Failed to fetch');
            return response.json();
        })
        .then(data => {
            hiddenInput.checked = data[sectionName][shortcutIndex]?.hidden || false;
        })
        .catch(error => {
            console.warn('Could not fetch links data for edit modal:', error);
            hiddenInput.checked = false;
        });

    modal.style.display = 'flex';
}

    function closeModal() {
      const modal = document.getElementById('editModal');
      modal.style.display = 'none';
      
      // Reset modal state
      document.getElementById('urlInputSection').style.display = 'block';
      document.getElementById('detailsSection').style.display = 'none';
      document.getElementById('fetchingIndicator').style.display = 'none';
      document.getElementById('fetchButton').style.display = 'none';
      document.getElementById('saveButton').style.display = 'none';
      
      // Clear inputs
      document.getElementById('editUrl').value = '';
      document.getElementById('editTitle').value = '';
      document.getElementById('editImage').value = '';
      document.getElementById('editHidden').checked = false;
      
      currentEditingShortcut = null;
    }

    async function fetchSiteInfo() {
      const urlInput = document.getElementById('editUrl');
      const titleInput = document.getElementById('editTitle');
      const imageInput = document.getElementById('editImage');
      const fetchingIndicator = document.getElementById('fetchingIndicator');
      const fetchButton = document.getElementById('fetchButton');
      const saveButton = document.getElementById('saveButton');
      const detailsSection = document.getElementById('detailsSection');
      
      let url = urlInput.value.trim();
      
      if (!url) {
        alert('Please enter a URL');
        return;
      }
      
      // Add https:// if no protocol is specified
      if (!url.match(/^https?:\/\//)) {
        url = 'https://' + url;
        urlInput.value = url;
      }
      
      // Validate URL
      try {
        new URL(url);
      } catch (e) {
        alert('Please enter a valid URL');
        return;
      }
      
      fetchingIndicator.style.display = 'block';
      fetchButton.style.display = 'none';
      
      try {
        // Extract domain for favicon
        const domain = new URL(url).hostname;
        
        // Try to fetch the page title
        let title = domain;
        try {
          // This is a simple approach - in a real implementation you might want to use a service
          // For now, we'll use the domain as the title and let users edit it
          title = domain.replace('www.', '').split('.')[0];
          title = title.charAt(0).toUpperCase() + title.slice(1);
        } catch (titleError) {
          console.warn('Could not fetch page title:', titleError);
        }
        
        // Generate favicon URL
        const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=64`;
        
        // Populate the form
        titleInput.value = title;
        imageInput.value = faviconUrl;
        
        // Show details section
        detailsSection.style.display = 'block';
        saveButton.style.display = 'inline-block';
        
      } catch (error) {
        console.error('Error fetching site info:', error);
        alert('Could not fetch site information. Please fill in the details manually.');
        
        // Show details section anyway so user can manually enter info
        detailsSection.style.display = 'block';
        saveButton.style.display = 'inline-block';
      }
      
      fetchingIndicator.style.display = 'none';
    }

    async function saveShortcut() {
      const title = document.getElementById('editTitle').value.trim();
      const url = document.getElementById('editUrl').value.trim();
      const image = document.getElementById('editImage').value.trim();
      const hidden = document.getElementById('editHidden').checked;
      
      if (!title || !url || !image) {
        alert('Please fill in all fields');
        return;
      }
      
      try {
        // Load current data
        const response = await fetch(LINKS_FILENAME);
        if (!response.ok) throw new Error('Failed to fetch current data');
        const data = await response.json();
        
        if (currentEditingShortcut) {
          // Editing existing shortcut
          const sectionName = currentEditingShortcut.closest('.section-row').getAttribute('data-section');
          const shortcutIndex = parseInt(currentEditingShortcut.getAttribute('data-index'));
          
          // Update the data
          data[sectionName][shortcutIndex] = { title, url, image, hidden };
          
          // Update the UI element
          currentEditingShortcut.href = url;
          currentEditingShortcut.querySelector('.title').textContent = title;
          currentEditingShortcut.querySelector('.shortcutimg').src = image;
          currentEditingShortcut.style.setProperty('--shortcut-background', `url('${image}')`);
          currentEditingShortcut.setAttribute('data-hidden', hidden);
        } else {
          // Adding new shortcut - we need to know which section
          const sectionName = currentEditingSectionName; // We'll need to store this
          if (!sectionName || !data[sectionName]) {
            alert('Error: Could not determine which section to add to');
            return;
          }
          
          // Add to data
          data[sectionName].push({ title, url, image, hidden });
        }
        
        // Try to save the data
        try {
          const saveResponse = await fetch(LINKS_FILENAME, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data, null, 2)
          });
          
          if (!saveResponse.ok) throw new Error('Save failed');
          
          console.log('Successfully saved shortcut');
          
          // Refresh the UI to show changes
          refreshUI();
          
        } catch (saveError) {
          console.warn('Could not save to file (expected in static hosting):', saveError);
          
          // For now, just update the UI and inform the user
          if (!currentEditingShortcut) {
            // For new shortcuts, refresh UI to show the change temporarily
            refreshUI();
          }
          
          alert('Shortcut updated in the interface, but could not be saved to file. Changes will be lost on page reload. To persist changes, you need a server that supports file writing.');
        }
        
      } catch (error) {
        console.error('Error saving shortcut:', error);
        alert('Error saving shortcut: ' + error.message);
      }
      
      closeModal();
    }

    function addShortcut(sectionName) {
      currentEditingShortcut = null;
      currentEditingSectionName = sectionName;
      
      // Set modal title for adding
      document.getElementById('modalTitle').textContent = `Add Shortcut to ${sectionName}`;
      
      // Reset modal state
      document.getElementById('urlInputSection').style.display = 'block';
      document.getElementById('detailsSection').style.display = 'none';
      document.getElementById('fetchingIndicator').style.display = 'none';
      document.getElementById('fetchButton').style.display = 'inline-block';
      document.getElementById('saveButton').style.display = 'none';
      
      // Clear inputs
      document.getElementById('editUrl').value = '';
      document.getElementById('editTitle').value = '';
      document.getElementById('editImage').value = '';
      document.getElementById('editHidden').checked = false;
      
      document.getElementById('editModal').style.display = 'flex';
      
      // Focus on URL input
      setTimeout(() => {
        document.getElementById('editUrl').focus();
      }, 100);
    }

    function saveChanges() {
      // Implement the logic to save changes to links.json
      const newData = {};
      const sections = document.getElementById('container').children;
      
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        const sectionTitle = section.querySelector('.section-title').textContent;
        const shortcuts = section.querySelectorAll('.shortcut');
        newData[sectionTitle] = Array.from(shortcuts).map(s => ({
          title: s.querySelector('.title').textContent,
          url: s.href,
          image: s.querySelector('.shortcutimg').src,
          hidden: s.getAttribute('data-hidden') === 'true'
        }));
      }

      // You'll need to implement server-side saving here
      console.log(`Save this data to ${LINKS_FILENAME}:`, newData);
    }

    // Add the shortcut size control handlers and functions
    function updateShortcutStyles() {
        const shortcutSizeSlider = document.getElementById('shortcutSizeSlider');
        const gapSizeSlider = document.getElementById('gapSizeSlider');
        const maxColumnsSelect = document.getElementById('maxColumnsSelect');
        
        const shortcutSize = shortcutSizeSlider.value;
        const gapSize = gapSizeSlider.value;
        const maxColumns = maxColumnsSelect.value;

        document.getElementById('shortcutSizeValue').textContent = shortcutSize;
        document.getElementById('gapSizeValue').textContent = gapSize;

        // Update CSS custom properties
        document.documentElement.style.setProperty('--shortcut-size', `${shortcutSize}px`);
        document.documentElement.style.setProperty('--gap-size', `${gapSize}px`);

        const style = document.createElement('style');
        
        if (maxColumns === 'unlimited') {
            // Unlimited: Keep the current section-based layout
            style.textContent = `
                .shortcut {
                    width: ${shortcutSize}px !important;
                    height: ${shortcutSize}px !important;
                }
                .section-row {
                    gap: ${gapSize}px ${gapSize}px !important;
                    display: flex !important; 
                    flex-flow: row wrap !important;
                    background: linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.2) 80%, transparent 100%) !important;
                    border-radius: 30px !important;
                }
                #container {
                    display: flex !important;
                    flex-direction: row !important;
                    flex-wrap: wrap !important;
                }
                .section-wrapper {
                    display: flex !important;
                    flex-direction: column !important;
                }
                .chevron-button {
                    position: relative !important;
                    width: 25px !important;
                    height: ${shortcutSize}px !important;
                    border-radius: 0px 28px 28px 0px !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    cursor: pointer !important;
                    flex: 0 0 auto !important;
                    background: linear-gradient(90deg,rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.2) 100%) !important;
                    transition: background-color 0.3s ease, transform 0.2s ease !important;
                }
                .chevron-button:hover {
                    background: linear-gradient(90deg,rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.4) 100%) !important;
                    transform: scale(1.05) !important;
                }
                .chevron-button .chevron-icon {
                    color: white !important;
                    border: solid white !important;
                    border-width: 0 3px 3px 0 !important;
                    display: inline-block !important;
                    padding: 3px !important;
                    transform: rotate(-45deg) !important;
                    -webkit-transform: rotate(-45deg) !important;
                    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                }
                .chevron-button.expanded .chevron-icon {
                    transform: rotate(135deg) !important;
                }
                .hidden-shortcuts-container .hidden-shortcut {
                    opacity: 0 !important;
                    transform: scale(0.8) translateY(-10px) !important;
                    transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1), transform 0.4s cubic-bezier(0.4, 0, 0.2, 1) !important;
                    transition-delay: 0s !important;
                }
                .hidden-shortcuts-container.expanded .hidden-shortcut {
                    opacity: 1 !important;
                    transform: scale(1) translateY(0) !important;
                    transition-delay: 0.1s !important;
                }
                .hidden-shortcuts-container:not(.expanded) .hidden-shortcut {
                    display: none !important;
                }
                body.dark-mode .chevron-button .chevron-icon {
                    border-color: white !important;
                }
            `;
        } else {
            // Limited columns: Change to global grid layout
            const totalWidth = parseInt(maxColumns) * (parseInt(shortcutSize) + parseInt(gapSize)) - parseInt(gapSize);
            style.textContent = `
                .shortcut, .hidden-shortcut {
                    width: ${shortcutSize}px !important;
                    height: ${shortcutSize}px !important;
                }
                #container {
                    display: grid !important;
                    grid-template-columns: repeat(${maxColumns}, ${shortcutSize}px) !important;
                    gap: ${gapSize}px !important;
                    justify-content: flex-start !important;
                    align-items: start !important;
                    width: ${totalWidth}px !important;
                }
                .section-wrapper {
                    display: contents !important;
                }
                .section-title {
                    grid-column: 1 / -1 !important;
                    margin: 20px 0 10px 0 !important;
                }
                .section-row {
                    display: grid !important;
                    grid-template-columns: subgrid !important;
                    grid-column: 1 / -1 !important;
                    gap: ${gapSize}px !important;
                    background: linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.2) 80%, transparent 100%) !important;
                    border-radius: 25px !important;
                    padding: ${gapSize}px !important;
                    margin-bottom: ${gapSize}px !important;
                }
                .shortcut-wrapper {
                    display: contents !important;
                }
                .hidden-shortcuts-container {
                    display: contents !important;
                }
                .hidden-shortcuts-container:not(.expanded) .hidden-shortcut {
                    display: none !important;
                }
                .chevron-button {
                    position: relative !important;
                    width: 25px !important;
                    height: ${shortcutSize}px !important;
                    border-radius: 0px 28px 28px 0px !important;
                    display: flex !important;
                    align-items: center !important;
                    justify-content: center !important;
                    cursor: pointer !important;
                    flex: 0 0 auto !important;
                    background: linear-gradient(90deg,rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0.2) 100%) !important;
                }
                .chevron-button .chevron-icon {
                    color: white !important;
                    border: solid white !important;
                    border-width: 0 3px 3px 0 !important;
                    display: inline-block !important;
                    padding: 3px !important;
                    transform: rotate(-45deg) !important;
                    -webkit-transform: rotate(-45deg) !important;
                    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
                }
                .chevron-button.expanded .chevron-icon {
                    transform: rotate(135deg) !important;
                }
                body.dark-mode .chevron-button .chevron-icon {
                    border-color: white !important;
                }
            `;
        }

        // Remove any previous dynamic styles
        const existingStyle = document.getElementById('dynamic-shortcut-styles');
        if (existingStyle) {
            existingStyle.remove();
        }
        style.id = 'dynamic-shortcut-styles';
        document.head.appendChild(style);

        if (localStorage.getItem('persistSettings') === 'true') {
            saveConfig();
        }
    }

    function autoAdjustShortcutSize() {
        const viewportWidth = window.innerWidth;
        const shortcutSizeSlider = document.getElementById('shortcutSizeSlider');
        const gapSizeSlider = document.getElementById('gapSizeSlider');
        
        // Shortcut size scaling
        // - Base size: 64px at 400px viewport
        // - Increases by 4px every 50px of viewport width
        // - Clamp between 64px and 184px
        const baseShortcutSize = 64;
        const shortcutGrowthRate = 4 / 50; // 4px increase per 50px of width
        const shortcutSize = Math.round(baseShortcutSize + (viewportWidth - 400) * shortcutGrowthRate);
        const newShortcutSize = Math.max(64, Math.min(184, shortcutSize));

        // Gap size scaling
        // - Base size: 5px at 400px viewport
        // - Increases by 2px every 50px of viewport width
        // - Clamp between 5px and 40px
        const baseGapSize = 5;
        const gapGrowthRate = 2 / 50; // 2px increase per 50px of width
        const gapSize = Math.round(baseGapSize + (viewportWidth - 400) * gapGrowthRate);
        const newGapSize = Math.max(5, Math.min(40, gapSize));

        // Update shortcut size slider and value
        shortcutSizeSlider.value = newShortcutSize;
        document.getElementById('shortcutSizeValue').textContent = newShortcutSize;
        
        // Update gap size slider and value
        gapSizeSlider.value = newGapSize;
        document.getElementById('gapSizeValue').textContent = newGapSize;
        
        // Update styles
        updateShortcutStyles();
    }

    function saveConfig() {
        const shortcutSizeSlider = document.getElementById('shortcutSizeSlider');
        const gapSizeSlider = document.getElementById('gapSizeSlider');
        const maxColumnsSelect = document.getElementById('maxColumnsSelect');
        const shadowSlider = document.getElementById('shadowSlider');
        
        const config = {
            darkMode: document.body.classList.contains('dark-mode'),
            backgroundImage: document.querySelector('.background-overlay').style.backgroundImage,
            timestamp: new Date().toISOString(),
            linksData: null,
            shortcutSize: shortcutSizeSlider ? shortcutSizeSlider.value : 124,
            gapSize: gapSizeSlider ? gapSizeSlider.value : 10,
            maxColumns: maxColumnsSelect ? maxColumnsSelect.value : 'unlimited',
            autoFitEnabled: autoFitEnabled,
            shadowSize: shadowSlider ? shadowSlider.value : 3,
            blur: document.getElementById('blurSlider') ? document.getElementById('blurSlider').value : 0,
            brightness: document.getElementById('brightnessSlider') ? document.getElementById('brightnessSlider').value : 100,
            contrast: document.getElementById('contrastSlider') ? document.getElementById('contrastSlider').value : 100
        };
        
        // Save the links data
        fetch(LINKS_FILENAME)
            .then(response => response.json())
            .then(data => {
                config.linksData = data;
                localStorage.setItem('siteConfig', JSON.stringify(config));
                console.log('Configuration saved:', config);
            })
            .catch(error => {
                // Save config without links data if fetch fails
                localStorage.setItem('siteConfig', JSON.stringify(config));
                console.log('Configuration saved (without links data):', config);
            });
    }

    // Background and shadow control functions
    const updateBackgroundFilter = () => {
        const blurSlider = document.getElementById('blurSlider');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const contrastSlider = document.getElementById('contrastSlider');
        
        if (!blurSlider || !brightnessSlider || !contrastSlider) return;
        
        const blur = blurSlider.value;
        const brightness = brightnessSlider.value / 100;
        const contrast = contrastSlider.value / 100;
        
        document.getElementById('blurValue').textContent = blur;
        document.getElementById('brightnessValue').textContent = brightness.toFixed(2);
        document.getElementById('contrastValue').textContent = contrast.toFixed(2);
        
        const overlay = document.querySelector('.background-overlay');
        if (overlay) {
            overlay.style.filter = `blur(${blur}px) brightness(${brightness}) contrast(${contrast})`;
        }
        
        if (localStorage.getItem('persistSettings') === 'true') {
            saveConfig();
        }
    };

    const updateShadow = () => {
        const shadowSlider = document.getElementById('shadowSlider');
        if (!shadowSlider) return;
        
        const shadow = shadowSlider.value;
        document.getElementById('shadowValue').textContent = shadow;
        document.documentElement.style.setProperty('--shadow-size', `${shadow}px`);
        
        if (localStorage.getItem('persistSettings') === 'true') {
            saveConfig();
        }
    };

    // Add event listeners for background and shadow controls
    ['blurSlider', 'brightnessSlider', 'contrastSlider'].forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            element.addEventListener('input', updateBackgroundFilter);
        }
    });

    const shadowSlider = document.getElementById('shadowSlider');
    if (shadowSlider) {
        shadowSlider.addEventListener('input', updateShadow);
    }

    // Initialize UI values and add event listeners for layout controls
    function initializeUIValues() {
        // Add event listeners for layout sliders
        const shortcutSizeSlider = document.getElementById('shortcutSizeSlider');
        const gapSizeSlider = document.getElementById('gapSizeSlider');
        const maxColumnsSelect = document.getElementById('maxColumnsSelect');
        
        if (shortcutSizeSlider) {
            shortcutSizeSlider.addEventListener('input', updateShortcutStyles);
        }
        if (gapSizeSlider) {
            gapSizeSlider.addEventListener('input', updateShortcutStyles);
        }
        if (maxColumnsSelect) {
            maxColumnsSelect.addEventListener('change', updateShortcutStyles);
        }
        
        // Initialize slider values
        updateShortcutStyles();
    }

    // Background setting functions
    function setBackgroundFromUrl() {
        const bgUrlInput = document.getElementById('bgUrlInput');
        if (bgUrlInput && bgUrlInput.value) {
            const overlay = document.querySelector('.background-overlay');
            if (overlay) {
                overlay.style.backgroundImage = `url("${bgUrlInput.value}")`;
                if (localStorage.getItem('persistSettings') === 'true') {
                    saveConfig();
                }
            }
        }
    }

    // Handle file uploads for background
    const bgFileInput = document.getElementById('bgFileInput');
    if (bgFileInput) {
        bgFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const overlay = document.querySelector('.background-overlay');
                    if (overlay) {
                        overlay.style.backgroundImage = `url("${e.target.result}")`;
                        if (localStorage.getItem('persistSettings') === 'true') {
                            saveConfig();
                        }
                    }
                };
                reader.readAsDataURL(file);
            }
        });
    }

    // Storage permission function
    function requestStoragePermission(event) {
        event.preventDefault();
        if (confirm("Would you like your browser to save your settings permanently?")) {
            localStorage.setItem('persistSettings', 'true');
            saveConfig();
            alert('Your settings will now be saved automatically!');
        } else {
            localStorage.removeItem('persistSettings');
            localStorage.removeItem('siteConfig');
            alert('Settings will not be saved between sessions.');
        }
    }

    // Export/Import config functions
    function exportConfig() {
        fetch(LINKS_FILENAME)
            .then(response => response.json())
            .then(data => {
                const config = {
                    darkMode: document.body.classList.contains('dark-mode'),
                    backgroundImage: document.querySelector('.background-overlay').style.backgroundImage,
                    timestamp: new Date().toISOString(),
                    linksData: data,
                    shortcutSize: document.getElementById('shortcutSizeSlider').value,
                    gapSize: document.getElementById('gapSizeSlider').value,
                    maxColumns: document.getElementById('maxColumnsSelect').value,
                    autoFitEnabled: autoFitEnabled
                };
                
                const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'site-config.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
    }
    
    function importConfig() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const config = JSON.parse(event.target.result);
                    if (config.darkMode !== document.body.classList.contains('dark-mode')) {
                        toggleMode();
                    }
                    if (config.linksData) {
                        const container = document.getElementById('container');
                        container.innerHTML = '';
                        refreshUI();
                    }
                    if (config.shortcutSize) document.getElementById('shortcutSizeSlider').value = config.shortcutSize;
                    if (config.gapSize) document.getElementById('gapSizeSlider').value = config.gapSize;
                    if (config.maxColumns) document.getElementById('maxColumnsSelect').value = config.maxColumns;
                    if (config.autoFitEnabled !== undefined) {
                        autoFitEnabled = config.autoFitEnabled;
                        document.getElementById('autoFitEnabled').textContent = autoFitEnabled ? 'Reset sizes' : 'Auto fit';
                    }
                    updateShortcutStyles();
                    saveConfig();
                } catch (err) {
                    alert('Invalid configuration file');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    // Menu toggle function
    function toggleMenu() {
        const burgerButton = document.querySelector('.burger-button');
        const menuContent = document.querySelector('.menu-content');
        if (burgerButton && menuContent) {
            burgerButton.classList.toggle('active');
            menuContent.classList.toggle('active');
        }
    }

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
        const burgerMenu = document.querySelector('.burger-menu');
        const burgerButton = document.querySelector('.burger-button');
        const menuContent = document.querySelector('.menu-content');
        
        if (burgerMenu && menuContent && !burgerMenu.contains(e.target) && menuContent.classList.contains('active')) {
            if (burgerButton) burgerButton.classList.remove('active');
            menuContent.classList.remove('active');
        }
    });

    // Initialize everything when the page loads
    loadLinks();

    // Load saved configuration and initialize UI after a short delay
    setTimeout(() => {
        loadConfig();
        initializeUIValues();
        updateShortcutStyles();
    }, 200);

    // Load saved configuration function
    async function loadConfig() {
        const savedConfig = localStorage.getItem('siteConfig');
        if (savedConfig) {
            try {
                const config = JSON.parse(savedConfig);
                
                // Apply auto-fit state
                if (config.autoFitEnabled !== undefined) {
                    autoFitEnabled = config.autoFitEnabled;
                    const autoFitButton = document.getElementById('autoFitEnabled');
                    if (autoFitButton) {
                        autoFitButton.textContent = autoFitEnabled ? 'Reset sizes' : 'Auto fit';
                    }
                }
                
                // Apply other settings
                if (config.shortcutSize) {
                    const slider = document.getElementById('shortcutSizeSlider');
                    if (slider) {
                        slider.value = config.shortcutSize;
                        document.getElementById('shortcutSizeValue').textContent = config.shortcutSize;
                    }
                }
                if (config.gapSize) {
                    const slider = document.getElementById('gapSizeSlider');
                    if (slider) {
                        slider.value = config.gapSize;
                        document.getElementById('gapSizeValue').textContent = config.gapSize;
                    }
                }
                if (config.maxColumns) {
                    const select = document.getElementById('maxColumnsSelect');
                    if (select) select.value = config.maxColumns;
                }
                if (config.shadowSize) {
                    const slider = document.getElementById('shadowSlider');
                    if (slider) {
                        slider.value = config.shadowSize;
                        document.getElementById('shadowValue').textContent = config.shadowSize;
                        document.documentElement.style.setProperty('--shadow-size', `${config.shadowSize}px`);
                    }
                }
                
                // Apply background settings
                if (config.blur !== undefined) {
                    const slider = document.getElementById('blurSlider');
                    if (slider) {
                        slider.value = config.blur;
                        document.getElementById('blurValue').textContent = config.blur;
                    }
                }
                if (config.brightness !== undefined) {
                    const slider = document.getElementById('brightnessSlider');
                    if (slider) {
                        slider.value = config.brightness;
                        document.getElementById('brightnessValue').textContent = (config.brightness / 100).toFixed(2);
                    }
                }
                if (config.contrast !== undefined) {
                    const slider = document.getElementById('contrastSlider');
                    if (slider) {
                        slider.value = config.contrast;
                        document.getElementById('contrastValue').textContent = (config.contrast / 100).toFixed(2);
                    }
                }
                
                // Apply background image
                if (config.backgroundImage) {
                    const overlay = document.querySelector('.background-overlay');
                    if (overlay) overlay.style.backgroundImage = config.backgroundImage;
                }
                
                // Apply background filters
                updateBackgroundFilter();
                
                console.log('Configuration loaded:', config);
            } catch (error) {
                console.warn('Error loading saved configuration:', error);
            }
        }
    }

    // ...existing code...
</script>
<script>
  // Wait for the page to fully load
  document.addEventListener('DOMContentLoaded', function() {
    // Find the element with the class 'background-overlay'
    const backgroundElement = document.querySelector('.background-overlay');

    // Check if the element exists
    if (backgroundElement) {
      // Apply the background style from the variable defined on line 9
      backgroundElement.style.background = DEFAULT_BACKGROUND_URL;
    }
  });
</script>
</body>
</html>
