<!DOCTYPE html>
<html>

<head>
  <script>
    // ===== CONFIGURATION =====
    // Change this to use a different links file (e.g., 'links-work.json', 'links-gaming.json')
    const LINKS_FILENAME = 'links-private.json';
    // =========================
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/color-thief/2.3.2/color-thief.umd.js"></script>
  <meta charset="utf-8" />
  <title>Links</title>
  <style>
    :root {
      --light-text: #ffffff;
      --dark-text: #000000;
      --light-scfill: 150, 150, 150;
      --dark-scfill: 50, 50, 50;
      --shortcut-size: 140px;
      --gap-size: 10px;
      --shadow-size: 3px;
}

    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background-color: var(--light-bg);
      color: var(--light-text);
      transition: background-color 0.3s, color 0.3s;
      width: 100%;
      height: 100%;
    }

    body.dark-mode {
      color: var(--dark-text);
    }

    .background-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url("https://i.imgur.com/yXXStJ4.jpeg") no-repeat center center fixed;
      background-size: cover;
      z-index: -1;
      filter:brightness(1) contrast(1);
    }
    /* .background-overlay.dark-mode {
      filter:brightness(0.6) contrast(1);
    } */

    .toggle {
      position: absolute;
      cursor: pointer;
      border: none;
      background: none;
      color: inherit;
      font-size: 1rem;
      top: 0px;
      right: 0px;
    }
    .toggle.dark-mode {
      rotate: 180deg;
      top: -3px;
      right: 0px;
    }

    #container {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      align-items: flex-start;
      margin-top: 30px;
      margin-left: 30px;
      gap: 20px;
      max-width: calc(100vw - 60px);
    }

    .section-title {
      text-align: left !important;
      margin: 15px 0 0 0;
      font-size: 1.2rem;
      color: inherit;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .section-title,
    .title {
      filter: drop-shadow(0 0 12px rgb(var(--light-scfill)));
    }
    .section-title.dark-mode {
      filter: drop-shadow(0 0 12px white);
    } 

    .section-row {
      display: flex;
      flex-flow: row wrap;
      overflow-x: auto;
      margin: 10px 0 0 0;
      padding: 5px 10px; /* Reduced vertical padding for normal mode */
      justify-content: flex-start;
      gap: var(--gap-size) var(--gap-size);
      background: linear-gradient(to bottom, rgba(0,0,0,0.3) 0%, rgba(0,0,0,0.2) 80%, transparent 100%);
      border-radius: 30px;
    }

    .edit-mode .section-row {
      padding: 10px; /* Full padding in edit mode */
      padding-bottom: 40px; /* Extra space for edit/delete buttons */
    }

    .section-title,
    .shortcut,
    .shortcutimg,
    .section-row {
    transition: all 0.5s ease-in-out;
  }

    @media (max-width: 719px) {
      .shortcut {
        max-width: 110px;
        max-height: 110px;
        margin: 15px 5px;
        transition: max-width 0.5s ease-in-out, max-height 0.5s ease-in-out, margin 0.5s ease-in-out;
      }
      .shortcut img {
        max-width: 50px;
        max-height: 50px;
        transition: max-width 0.5s ease-in-out, max-height 0.5s ease-in-out;
      }
      .section-row {
        gap: 15px 5px;
      }
    }
    
    .shortcut {
      position: relative;
      flex: 0 0 auto;
      width: var(--shortcut-size);
      height: var(--shortcut-size);
      /* margin: 0 10px; */
      border-radius: 25px;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: inherit;
      background: none;
      background-size: cover;
      background-position: center;
      overflow: hidden;
      opacity: 1;
      
    }

    body:not(.edit-mode) .shortcut:hover::before,
    body:not(.edit-mode) .shortcut:hover {
      scale: 1.1;
    }

    body:not(.edit-mode) .shortcut:hover .shortcutimg {
      filter: drop-shadow(0 0 calc(2px * 1.1) black) drop-shadow(0 0 calc(var(--shadow-size) * 1.1) white);
    }

    body:not(.edit-mode) .shortcut:hover .shortcutimg.dark-mode {
      filter: drop-shadow(0 0 calc(2px * 1.1) rgb(229, 229, 229)) 
              drop-shadow(0 0 calc(var(--shadow-size) * 1.1) black) 
              drop-shadow(0 0 calc(8px * 1.1) rgb(var(--dark-scfill)));
    }

    .shortcut::before {
      content: "";
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      filter: blur(12px) brightness(0.5) contrast(0.8) opacity(0.7);
      transform: scale(0.95, 0.95) translate(0%, -10%);
      opacity: 1;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 1;
      background-image: var(--shortcut-background);
      background-color: rgba(0,0,0,0.4);
    }
    .shortcut.dark-mode::before {
      background-color: rgb(65, 65, 65);
      filter: blur(12px) brightness(1) contrast(0.8) opacity(0.5);
    }

    .shortcutimg {
      margin-top: 10px;
      object-fit: contain;
      position: relative;
      width: 50%;
      height: 50%;
      z-index: 1;
      filter: drop-shadow(0 0 2px black) drop-shadow(0 0 var(--shadow-size) white); /*drop-shadow(0 0 8px rgb(var(--light-scfill)))*/
    }
  
    .shortcutimg.dark-mode {
      filter: drop-shadow(0 0 2px rgb(229, 229, 229)) drop-shadow(0 0 var(--shadow-size) black) drop-shadow(0 0 8px rgb(var(--dark-scfill))) ;
    }


    .title {
      position: relative;
      z-index: 2;
      margin-top: 10px;
      margin-bottom: 5px;
      text-align: center;
    }
    a {
  text-decoration: none !important;
  font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
}

    .config-buttons {
  position: absolute;
  top: 40px;
  right: 10px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.config-button {
  padding: 8px 12px;
  border: none;
  border-radius: 5px;
  background: rgba(0, 0, 0, 0.5);
  color: white;
  cursor: pointer;
  transition: background 0.3s;
}

.config-button:hover {
  background: rgba(0, 0, 0, 0.7);
}

body.dark-mode .config-button {
  background: rgba(255, 255, 255, 0.5);
  color: black;
}

body.dark-mode .config-button:hover {
  background: rgba(255, 255, 255, 0.7);
}

.edit-button {
  position: absolute;
  top: 10px;
  right: 120px;
  padding: 8px 12px;
  border: none;
  border-radius: 5px;
  background: rgba(0, 0, 0, 0.5);
  color: white;
  cursor: pointer;
  transition: background 0.3s;
}

.edit-button:hover {
  background: rgba(0, 0, 0, 0.7);
}

body.dark-mode .edit-button {
  background: rgba(255, 255, 255, 0.5);
  color: black;
}

body.dark-mode .edit-button:hover {
  background: rgba(255, 255, 255, 0.7);
}

.edit-mode .shortcut {
  position: relative;
}

.delete-shortcut {
  display: none;
  position: relative;
  margin-top: 5px;
  margin-left: auto;
  z-index: 3;
  width: 32px;
  height: 24px;
  cursor: pointer;
  background: linear-gradient(135deg, #ff4757 0%, #ff3742 50%, #e55039 100%);
  color: white;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  font-weight: 700;
  box-shadow: 0 4px 16px rgba(255, 71, 87, 0.3), 
              0 2px 6px rgba(0, 0, 0, 0.2),
              inset 0 1px 2px rgba(255, 255, 255, 0.3),
              inset 0 -1px 1px rgba(0, 0, 0, 0.1);
  border: 1.5px solid rgba(255, 255, 255, 0.6);
  backdrop-filter: blur(12px);
  transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  transform: translateZ(0) scale(0.95);
  opacity: 0.92;
}

.delete-shortcut:hover {
  background: linear-gradient(135deg, #ff3742 0%, #e55039 50%, #c44569 100%);
  transform: translateZ(0) scale(1.08);
  box-shadow: 0 8px 24px rgba(255, 71, 87, 0.5), 
              0 4px 12px rgba(0, 0, 0, 0.3),
              inset 0 1px 3px rgba(255, 255, 255, 0.4),
              inset 0 -1px 2px rgba(0, 0, 0, 0.1);
  border-color: rgba(255, 255, 255, 0.9);
  opacity: 1;
}

.delete-shortcut:active {
  transform: translateZ(0) scale(0.88);
  box-shadow: 0 2px 8px rgba(255, 71, 87, 0.3);
  transition: all 0.1s ease-out;
}

.edit-shortcut {
  display: none;
  position: relative;
  margin-top: 5px;
  margin-right: 10px;
  z-index: 3;
  flex: 1;
  height: 24px;
  cursor: pointer;
  background: linear-gradient(135deg, #3742fa 0%, #2f3542 50%, #40739e 100%);
  color: white;
  border-radius: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  font-weight: 700;
  box-shadow: 0 4px 16px rgba(55, 66, 250, 0.3), 
              0 2px 6px rgba(0, 0, 0, 0.2),
              inset 0 1px 2px rgba(255, 255, 255, 0.3),
              inset 0 -1px 1px rgba(0, 0, 0, 0.1);
  border: 1.5px solid rgba(255, 255, 255, 0.6);
  backdrop-filter: blur(12px);
  transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  transform: translateZ(0) scale(0.95);
  opacity: 0.92;
}

.edit-shortcut:hover {
  background: linear-gradient(135deg, #2f3542 0%, #40739e 50%, #487eb0 100%);
  transform: translateZ(0) scale(1.08);
  box-shadow: 0 8px 24px rgba(55, 66, 250, 0.5), 
              0 4px 12px rgba(0, 0, 0, 0.3),
              inset 0 1px 3px rgba(255, 255, 255, 0.4),
              inset 0 -1px 2px rgba(0, 0, 0, 0.1);
  border-color: rgba(255, 255, 255, 0.9);
  opacity: 1;
}

.edit-shortcut:active {
  transform: translateZ(0) scale(0.88);
  box-shadow: 0 2px 8px rgba(55, 66, 250, 0.3);
  transition: all 0.1s ease-out;
}

.edit-mode .shortcut-buttons {
  display: flex;
}

.add-shortcut {
  display: none;
  width: 140px;
  height: 140px;
  border: 2px dashed #ccc;
  border-radius: 25px;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  background: rgba(255,255,255,0.1);
}

.edit-mode .add-shortcut {
  display: flex;
}

.modal {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.7);
  z-index: 1000;
  justify-content: center;
  align-items: center;
  backdrop-filter: blur(5px);
}

.modal-content {
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 30px;
  border-radius: 25px;
  width: 400px;
  max-width: 90vw;
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  border: 1px solid rgba(255,255,255,0.1);
}

.modal-content h3 {
  margin-top: 0;
  margin-bottom: 20px;
  color: white;
  text-align: center;
  font-size: 1.3em;
}

.modal-content input {
  width: calc(100% - 20px);
  margin: 10px 0;
  padding: 12px;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  background: rgba(255,255,255,0.1);
  color: white;
  font-size: 14px;
}

.modal-content input::placeholder {
  color: rgba(255,255,255,0.6);
}

.modal-content input:focus {
  outline: none;
  border-color: rgba(255,255,255,0.4);
  background: rgba(255,255,255,0.15);
}

.modal-content label {
  color: white !important;
}

#fetchingIndicator {
  color: rgba(255,255,255,0.7) !important;
  font-style: italic;
  text-align: center;
}

body.dark-mode .modal-content {
  background: rgba(255,255,255,0.8);
  color: black;
  border: 1px solid rgba(0,0,0,0.1);
}

body.dark-mode .modal-content h3 {
  color: black;
}

body.dark-mode .modal-content input {
  background: rgba(0,0,0,0.1);
  color: black;
  border: 1px solid rgba(0,0,0,0.2);
}

body.dark-mode .modal-content input::placeholder {
  color: rgba(0,0,0,0.6);
}

body.dark-mode .modal-content input:focus {
  background: rgba(0,0,0,0.15);
  border-color: rgba(0,0,0,0.4);
}

body.dark-mode .modal-content label {
  color: black !important;
}

body.dark-mode #fetchingIndicator {
  color: rgba(0,0,0,0.7) !important;
}

.modal-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 15px;
  margin-top: 20px;
}

.modal-buttons button {
  padding: 10px 20px;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 8px;
  background: rgba(255,255,255,0.1);
  color: white;
  cursor: pointer;
  transition: all 0.3s ease;
  font-size: 14px;
}

.modal-buttons button:hover {
  background: rgba(255,255,255,0.2);
  border-color: rgba(255,255,255,0.5);
}

.modal-buttons button:active {
  transform: scale(0.98);
}

body.dark-mode .modal-buttons button {
  background: rgba(0,0,0,0.1);
  color: black;
  border: 1px solid rgba(0,0,0,0.3);
}

body.dark-mode .modal-buttons button:hover {
  background: rgba(0,0,0,0.2);
  border-color: rgba(0,0,0,0.5);
}

.modal-checkbox-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 10px 0;
  padding: 12px 0;
}

.modal-checkbox-container input[type="checkbox"] {
  width: auto !important;
  margin: 0 !important;
  transform: scale(1.2);
}

.modal-checkbox-container label {
  margin: 0 !important;
  white-space: nowrap;
  cursor: pointer;
}
    
    .burger-menu {
  position: fixed;
  top: 20px;
  right: 20px;
  z-index: 1000;
}

.burger-button {
  width: 40px;
  height: 40px;
  background: rgba(0, 0, 0, 0.5);
  border: none;
  border-radius: 5px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  gap: 6px;
  padding: 8px;
}

.burger-button span {
  width: 24px;
  height: 2px;
  background: white;
  transition: all 0.3s;
}

.burger-button.active span:nth-child(1) {
  transform: rotate(45deg) translate(5.5px, 5.5px);
}

.burger-button.active span:nth-child(2) {
  opacity: 0;
}

.burger-button.active span:nth-child(3) {
  transform: rotate(-45deg) translate(5.5px, -5.5px); 
}

.menu-content {
  position: fixed;
  top: 70px;
  right: -200px;
  width: 150px;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 5px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  transition: right 0.3s;
}

.menu-content.active {
  right: 20px;
}

body.dark-mode .burger-button {
  background: rgba(255, 255, 255, 0.5);
}

body.dark-mode .burger-button span {
  background: black;
}

body.dark-mode .menu-content {
  background: rgba(255, 255, 255, 0.8);
}

.menu-button {
  text-align: left;
  padding: 8px 12px;
  border: none;
  border-radius: 5px;
  background: rgba(0, 0, 0, 0.5);
  color: white;
  cursor: pointer;
  transition: background 0.3s;
}

body.dark-mode .menu-button {
  background: rgba(255, 255, 255, 0.5);
  color: black;
}

.menu-button:hover {
  background: rgba(0, 0, 0, 0.7);
}

body.dark-mode .menu-button:hover {
  background: rgba(255, 255, 255, 0.7);
}

.menu-section {
      padding: 5px;
    }

    .menu-section-title {
      color: inherit;
      font-size: 0.9em;
      margin-bottom: 5px;
      display: block;
    }

    .menu-input-group {
      display: flex;
      gap: 5px;
      margin-bottom: 5px;
    }

    .menu-input {
      flex: 1;
      padding: 5px;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 3px;
      background: rgba(0,0,0,0.3);
      color: white;
    }

    body.dark-mode .menu-input {
      background: rgba(255,255,255,0.3);
      color: black;
    }

    .menu-button.small {
      padding: 4px 8px;
    }

    .menu-slider-group {
      margin: 10px 0;
    }

    .menu-slider-group label {
      font-size: 0.8em;
      display: block;
      margin-bottom: 3px;
    }

    .menu-slider {
      width: 100%;
      margin: 5px 0;
    }
    /* Add to existing styles */
    .menu-checkbox-group {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-top: 5px;
    }

    .menu-checkbox {
        accent-color: rgba(255, 255, 255, 0.7);
    }

    body.dark-mode .menu-checkbox {
        accent-color: rgba(0, 0, 0, 0.7);
    }

/* Add after the .shortcut styles */
.shortcut.dragging {
  opacity: 0.5;
  cursor: move;
}

.shortcut.drag-over {
  border: 2px dashed #ffffff;
}

.section-row.drag-active {
  min-height: var(--shortcut-size);
  border: 2px dashed rgba(255, 255, 255, 0.3);
  border-radius: 10px;
}

/* Collapsed shortcuts styles */
.chevron-button {
  position: relative;
  width: 40px;
  height: var(--shortcut-size);
  /* background: rgba(255, 255, 255, 0.1); */
  /* border: 2px dashed rgba(255, 255, 255, 0.3); */
  border-radius: 25px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  /* transition: all 0.3s ease; */
  /* backdrop-filter: blur(10px); */
  flex: 0 0 auto;
}

.chevron-button:hover,
.chevron-button:focus {
  /* background: rgba(255, 255, 255, 0.2); */
  /* border-color: rgba(255, 255, 255, 0.5); */
  /* scale: 1.05; */
  outline: none;
}

.chevron-icon {
  /* font-size: 18px; */
  color: white;
  /* transition: transform 0.3s ease; */
  border: solid white;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

.chevron-button.expanded .chevron-icon {
  transform: rotate(135deg);
}

body.dark-mode .chevron-icon {
  /* color: #333; */
  border-color: white;
}

.hidden-shortcuts-container {
  display: none; /* Hidden by default */
  gap: var(--gap-size);
  opacity: 0;
  overflow: hidden;
  transition: opacity 0.4s ease;
  /* Remove flex-wrap since we want individual items to be flex items of section-row */
}

.hidden-shortcuts-container.expanded {
  display: contents; /* This makes the container "disappear" and its children become direct children of section-row */
  opacity: 1;
}

.hidden-shortcut {
  position: relative;
  flex: 0 0 auto;
  width: var(--shortcut-size);
  height: var(--shortcut-size);
  border-radius: 25px;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  color: inherit;
  background: none;
  background-size: cover;
  background-position: center;
  overflow: hidden;
  /* opacity: 0.7; */
  transition: all 0.3s ease;
  text-decoration: none;
}

body:not(.edit-mode) .hidden-shortcut:hover {
  opacity: 1;
  scale: 1.05;
}

.hidden-shortcut::before {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  filter: blur(12px) brightness(0.5) contrast(0.8) opacity(0.7);
  transform: scale(0.95, 0.95) translate(0%, -10%);
  opacity: 1;
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  z-index: 1;
  background-image: var(--shortcut-background);
  background-color: rgba(0,0,0,0.4);
}

body.dark-mode .hidden-shortcut::before {
  background-color: rgb(65, 65, 65);
  filter: blur(12px) brightness(1) contrast(0.8) opacity(0.5);
}

.hidden-shortcut .shortcutimg {
  margin-top: 10px;
  object-fit: contain;
  position: relative;
  width: 50%;
  height: 50%;
  z-index: 2;
  filter: drop-shadow(0 0 2px black) drop-shadow(0 0 var(--shadow-size) white);
}

body.dark-mode .hidden-shortcut .shortcutimg {
  filter: drop-shadow(0 0 2px rgb(229, 229, 229)) drop-shadow(0 0 var(--shadow-size) black) drop-shadow(0 0 8px rgb(var(--dark-scfill)));
}

.hidden-shortcut .title {
  position: relative;
  z-index: 2;
  margin-top: 10px;
  margin-bottom: 5px;
  text-align: center;
}

.shortcut-wrapper {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: var(--shortcut-size);
}

.shortcut-buttons {
  display: none;
  flex-direction: row;
  gap: 10px;
  width: 100%;
  margin-top: 5px;
}

.edit-mode .shortcut-buttons {
  display: flex;
}
  </style>
</head>

<body>
  <div class="background-overlay"></div>
  <div class="burger-menu">
    <button class="burger-button" onclick="toggleMenu()">
      <span></span>
      <span></span>
      <span></span>
    </button>
    <div class="menu-content">
      <button class="menu-button" onclick="toggleMode()">Toggle theme</button>
      <button class="menu-button" onclick="toggleEditMode()">Edit shortcuts</button>
      <button class="menu-button" id="toggleHiddenButton" onclick="toggleAllHidden()">Show all hidden</button>
      <button class="menu-button" onclick="exportConfig()">Export config</button>
      <button class="menu-button" onclick="importConfig()">Import config</button>
      <hr style="border: 1px solid rgba(255,255,255,0.2); width: 90%; margin: 5px auto;">
      <!-- Add Shortcut Size section -->
      <div class="menu-section">
        <span class="menu-section-title">Shortcut Size</span>
        <div class="menu-slider-group">
          <label>Shortcut size: <span id="shortcutSizeValue">124</span>px</label>
          <input type="range" id="shortcutSizeSlider" min="64" max="192" value="124" class="menu-slider">
        </div>
        <div class="menu-slider-group">
          <label>Gap size: <span id="gapSizeValue">10</span>px</label>
          <input type="range" id="gapSizeSlider" min="5" max="124" value="10" class="menu-slider">
          <div class="menu-slider-group">
            <label>Shadow: <span id="shadowValue">3</span>px</label>
            <input type="range" id="shadowSlider" min="3" max="15" value="3" class="menu-slider">
          </div>
          <div class="menu-checkbox-group">
            <input type="checkbox" id="autoFitEnabled" class="menu-checkbox">
            <label for="autoFitEnabled">Auto-fit sizes</label>
          </div>
          <button class="menu-button small" onclick="autoAdjustGap()">Auto-fit</button>
        </div>
        <div class="menu-input-group">
          <label>Max columns:</label>
          <select id="maxColumnsSelect" class="menu-input">
            <option value="unlimited">Unlimited</option>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
          </select>
        </div>
      </div>
      <hr style="border: 1px solid rgba(255,255,255,0.2); width: 90%; margin: 5px auto;">
      <!-- Add new background image section -->
      <div class="menu-section">
        <span class="menu-section-title">Background Image</span>
        <div class="menu-input-group">
          <input type="text" id="bgUrlInput" placeholder="Image URL" class="menu-input" style="width: 100%">
          <button class="menu-button small" onclick="setBackgroundFromUrl()">Set</button>
        </div>
        <div class="menu-input-group">
          <input type="file" id="bgFileInput" accept="image/*" class="menu-input" style="display: none">
          <button class="menu-button" onclick="document.getElementById('bgFileInput').click()">Upload Image</button>
        </div>
        <button class="menu-button" onclick="toggleDisplaySettings()">Display Settings</button>
      </div>
      <hr style="border: 1px solid rgba(255,255,255,0.2); width: 90%; margin: 5px auto;">
      <!-- Display settings section (hidden by default) -->
      <div id="displaySettings" class="menu-section">
        <span class="menu-section-title">Display Settings</span>
        <div class="menu-slider-group">
          <label>Blur: <span id="blurValue">0</span>px</label>
          <input type="range" id="blurSlider" min="0" max="20" value="0" class="menu-slider">
        </div>
        <div class="menu-slider-group">
          <label>Brightness: <span id="brightnessValue">100</span></label>
          <input type="range" id="brightnessSlider" min="1" max="100" value="100" class="menu-slider">
        </div>
        <div class="menu-slider-group">
          <label>Contrast: <span id="contrastValue">1.0</span></label>
          <input type="range" id="contrastSlider" min="1" max="200" value="100" class="menu-slider">
        </div>
      </div>
      <hr style="border: 1px solid rgba(255,255,255,0.2); width: 90%; margin: 5px auto;">
      <!-- Original persist settings button -->
      <a href="#" class="menu-button" onclick="requestStoragePermission(event)">
        Persist settings
      </a>
    </div>
  </div>
  
  <div id="editModal" class="modal">
    <div class="modal-content">
      <h3 id="modalTitle">Add Shortcut</h3>
      <div id="urlInputSection">
        <input type="text" id="editUrl" placeholder="Enter website URL (e.g., https://youtube.com)">
        <div id="fetchingIndicator" style="display: none; color: #666; margin: 5px 0;">
          Fetching site information...
        </div>
      </div>
      <div id="detailsSection" style="display: none;">
        <input type="text" id="editTitle" placeholder="Title">
        <input type="text" id="editImage" placeholder="Image URL">
        <div class="modal-checkbox-container">
          <input type="checkbox" id="editHidden">
          <label for="editHidden">Hide in collapsed view</label>
        </div>
      </div>
      <div class="modal-buttons">
        <button onclick="closeModal()">Cancel</button>
        <button id="fetchButton" onclick="fetchSiteInfo()" style="display: none;">Fetch Info</button>
        <button id="saveButton" onclick="saveShortcut()" style="display: none;">Save</button>
      </div>
    </div>
  </div>

  <div id="container"></div>

  <script>
    let editMode = false;
    let currentEditingShortcut = null;
    let currentEditingSectionName = null;

    function toggleEditMode() {
      editMode = !editMode;
      document.body.classList.toggle('edit-mode');
      refreshUI();
    }

    function refreshUI() {
      const container = document.getElementById('container');
      container.innerHTML = '';
      loadLinks();
    }

    async function loadLinks() {
  let data;
  try {
    console.log(`Attempting to load ${LINKS_FILENAME}...`);
    const response = await fetch(LINKS_FILENAME);
    console.log('Response status:', response.status, response.statusText);
    if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
    data = await response.json();
    console.log(`Successfully loaded ${LINKS_FILENAME} with`, Object.keys(data).length, 'sections');
  } catch (error) {
    console.error(`Could not load ${LINKS_FILENAME}, using sample data:`, error);
    alert(`Could not load your shortcuts from ${LINKS_FILENAME}. Using sample data instead. Make sure you're accessing the page through a web server (e.g., http://localhost:8000)`);
    // Fallback sample data when file can't be loaded (e.g., CORS issues)
    data = {
      "Watch": [
        {
          "title": "YouTube",
          "url": "https://www.youtube.com/",
          "image": "https://www.google.com/s2/favicons?domain=youtube.com&sz=64"
        },
        {
          "title": "Netflix",
          "url": "https://www.netflix.com/",
          "image": "https://www.google.com/s2/favicons?domain=netflix.com&sz=64"
        },
        {
          "title": "Twitch",
          "url": "https://www.twitch.tv/",
          "image": "https://www.google.com/s2/favicons?domain=twitch.tv&sz=64",
          "hidden": true
        }
      ],
      "Social": [
        {
          "title": "Twitter",
          "url": "https://twitter.com/",
          "image": "https://www.google.com/s2/favicons?domain=twitter.com&sz=64"
        },
        {
          "title": "Reddit",
          "url": "https://www.reddit.com/",
          "image": "https://www.google.com/s2/favicons?domain=reddit.com&sz=64"
        },
        {
          "title": "Instagram",
          "url": "https://www.instagram.com/",
          "image": "https://www.google.com/s2/favicons?domain=instagram.com&sz=64",
          "hidden": true
        },
        {
          "title": "TikTok",
          "url": "https://www.tiktok.com/",
          "image": "https://www.google.com/s2/favicons?domain=tiktok.com&sz=64",
          "hidden": true
        }
      ],
      "Work": [
        {
          "title": "Gmail",
          "url": "https://mail.google.com/",
          "image": "https://www.google.com/s2/favicons?domain=mail.google.com&sz=64"
        },
        {
          "title": "GitHub",
          "url": "https://github.com/",
          "image": "https://www.google.com/s2/favicons?domain=github.com&sz=64"
        },
        {
          "title": "Slack",
          "url": "https://slack.com/",
          "image": "https://www.google.com/s2/favicons?domain=slack.com&sz=64",
          "hidden": true
        }
      ]
    };
  }
  const container = document.getElementById('container');
  
  console.log('Rendering sections:', Object.keys(data));
  console.log('Total sections to render:', Object.keys(data).length);

  Object.entries(data).forEach(([sectionName, links]) => {
    console.log(`Rendering section: ${sectionName} with ${links.length} shortcuts`);
    // Create a section wrapper
    const sectionWrapper = document.createElement('div');
    sectionWrapper.className = 'section-wrapper';
    sectionWrapper.style.cssText = 'display: flex; flex-direction: column; min-width: 300px; flex: 0 1 auto;';

    const sectionTitle = document.createElement('h2');
    sectionTitle.className = 'section-title';
    sectionTitle.textContent = sectionName;
    sectionWrapper.appendChild(sectionTitle);

    const row = document.createElement('div');
    row.className = 'section-row';
    row.setAttribute('data-section', sectionName);

    if (editMode) {
      // In edit mode, render ALL shortcuts (hidden and visible) in the main row
      links.forEach((item, index) => {
        // Create wrapper for shortcut and buttons
        const shortcutWrapper = document.createElement('div');
        shortcutWrapper.className = 'shortcut-wrapper';
        
        const shortDiv = document.createElement('a');
        shortDiv.href = 'javascript:void(0)';
        shortDiv.className = 'shortcut';
        shortDiv.style.setProperty('--shortcut-background', `url('${item.image}')`);
        shortDiv.setAttribute('title', item.title);
        shortDiv.setAttribute('draggable', 'true');
        shortDiv.setAttribute('data-index', index);

        // Add drag and drop event listeners
        shortDiv.addEventListener('dragstart', handleDragStart);
        shortDiv.addEventListener('dragend', handleDragEnd);
        shortDiv.addEventListener('dragover', handleDragOver);
        shortDiv.addEventListener('dragenter', handleDragEnter);
        shortDiv.addEventListener('dragleave', handleDragLeave);
        shortDiv.addEventListener('drop', handleDrop);

        shortDiv.innerHTML = `
          <img src="${item.image}" class="shortcutimg" alt="${item.title}" />
          <div class="title">${item.title}</div>
        `;
        
        shortcutWrapper.appendChild(shortDiv);

        const buttonsDiv = document.createElement('div');
        buttonsDiv.className = 'shortcut-buttons';
        buttonsDiv.innerHTML = `
          <div class="edit-shortcut" onclick="editShortcut(this)">EDIT</div>
          <div class="delete-shortcut" onclick="deleteShortcut(this)">Ã—</div>
        `;
        shortcutWrapper.appendChild(buttonsDiv);
        
        row.appendChild(shortcutWrapper);
      });
    } else {
      // In normal mode, render visible shortcuts first
      links.forEach((item, index) => {
        // Skip hidden shortcuts - they'll be handled separately
        if (item.hidden) return;
        
        // Create wrapper for shortcut and buttons
        const shortcutWrapper = document.createElement('div');
        shortcutWrapper.className = 'shortcut-wrapper';
        
        const shortDiv = document.createElement('a');
        shortDiv.href = item.url;
        shortDiv.className = 'shortcut';
        shortDiv.style.setProperty('--shortcut-background', `url('${item.image}')`);
        shortDiv.setAttribute('title', item.title);
        shortDiv.setAttribute('draggable', 'true');
        shortDiv.setAttribute('data-index', index);

        // Add drag and drop event listeners
        shortDiv.addEventListener('dragstart', handleDragStart);
        shortDiv.addEventListener('dragend', handleDragEnd);
        shortDiv.addEventListener('dragover', handleDragOver);
        shortDiv.addEventListener('dragenter', handleDragEnter);
        shortDiv.addEventListener('dragleave', handleDragLeave);
        shortDiv.addEventListener('drop', handleDrop);

        shortDiv.innerHTML = `
          <img src="${item.image}" class="shortcutimg" alt="${item.title}" />
          <div class="title">${item.title}</div>
        `;
        
        shortcutWrapper.appendChild(shortDiv);
        row.appendChild(shortcutWrapper);
      });

      // Check if there are hidden shortcuts
      const hiddenShortcuts = links.filter(item => item.hidden);
      if (hiddenShortcuts.length > 0) {
        // Create hidden shortcuts container for inline expansion
        const hiddenContainer = document.createElement('div');
        hiddenContainer.className = 'hidden-shortcuts-container';
        
        hiddenShortcuts.forEach((item, index) => {
          // Create wrapper for hidden shortcut and buttons
          const hiddenWrapper = document.createElement('div');
          hiddenWrapper.className = 'shortcut-wrapper';
          
          const hiddenShortcut = document.createElement('a');
          hiddenShortcut.href = item.url;
          hiddenShortcut.target = '_blank';
          hiddenShortcut.className = 'hidden-shortcut';
          hiddenShortcut.style.setProperty('--shortcut-background', `url("${item.image}")`);
          hiddenShortcut.setAttribute('title', item.title);
          hiddenShortcut.setAttribute('draggable', 'true');
          // Find the actual index in the original links array for hidden shortcuts
          const actualIndex = links.findIndex(link => link === item);
          hiddenShortcut.setAttribute('data-index', actualIndex);
          
          hiddenShortcut.innerHTML = `
            <img src="${item.image}" alt="${item.title}" class="shortcutimg" />
            <div class="title">${item.title}</div>
          `;
          
          hiddenWrapper.appendChild(hiddenShortcut);
          hiddenContainer.appendChild(hiddenWrapper);
        });
        
        // Create chevron button
        const chevronButton = document.createElement('div');
        chevronButton.className = 'chevron-button';
        chevronButton.innerHTML = '<span class="chevron-icon"></span>';
        chevronButton.setAttribute('role', 'button');
        chevronButton.setAttribute('tabindex', '0');
        chevronButton.setAttribute('aria-expanded', 'false');
        chevronButton.setAttribute('aria-label', 'Show hidden shortcuts');
        
        chevronButton.addEventListener('click', () => {
          const isExpanded = chevronButton.classList.toggle('expanded');
          hiddenContainer.classList.toggle('expanded');
          chevronButton.setAttribute('aria-expanded', isExpanded);
          chevronButton.setAttribute('aria-label', isExpanded ? 'Hide hidden shortcuts' : 'Show hidden shortcuts');
          
          // Update the toggle all button text based on current state
          updateToggleAllButtonText();
        });

        // Add hidden container and chevron to row
        row.appendChild(hiddenContainer);
        row.appendChild(chevronButton);
      }
    }

    if (editMode) {
      const addButton = document.createElement('div');
      addButton.className = 'add-shortcut';
      addButton.innerHTML = '+';
      addButton.onclick = () => addShortcut(sectionName);
      row.appendChild(addButton);
    }

    sectionWrapper.appendChild(row);
    container.appendChild(sectionWrapper);
  });
}

function updateToggleAllButtonText() {
      const toggleButton = document.getElementById('toggleHiddenButton');
      if (!toggleButton) return;
      
      const hiddenContainers = document.querySelectorAll('.hidden-shortcuts-container');
      if (hiddenContainers.length === 0) {
        toggleButton.textContent = 'Show all hidden';
        return;
      }
      
      const anyExpanded = Array.from(hiddenContainers).some(container => 
        container.classList.contains('expanded')
      );
      
      const allExpanded = Array.from(hiddenContainers).every(container => 
        container.classList.contains('expanded')
      );
      
      if (allExpanded) {
        toggleButton.textContent = 'Hide all hidden';
      } else if (anyExpanded) {
        toggleButton.textContent = 'Show all hidden';
      } else {
        toggleButton.textContent = 'Show all hidden';
      }
    }

// Add these functions after the loadLinks function
let draggedElement = null;

function handleDragStart(e) {
  if (!editMode) return;
  
  draggedElement = this;
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', this.getAttribute('data-index'));
}

function handleDragEnd(e) {
  if (!editMode) return;
  
  this.classList.remove('dragging');
  const sections = document.querySelectorAll('.section-row');
  sections.forEach(section => {
    section.classList.remove('drag-active');
  });
}

function handleDragOver(e) {
  if (!editMode) return;
  
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
}

function handleDragEnter(e) {
  if (!editMode) return;
  
  e.preventDefault();
  this.classList.add('drag-over');
  this.closest('.section-row').classList.add('drag-active');
}

function handleDragLeave(e) {
  if (!editMode) return;
  
  this.classList.remove('drag-over');
}

function handleDrop(e) {
  if (!editMode) return;
  
  e.preventDefault();
  this.classList.remove('drag-over');
  
  const sourceIndex = parseInt(e.dataTransfer.getData('text/plain'));
  const targetIndex = parseInt(this.getAttribute('data-index'));
  
  if (sourceIndex === targetIndex) return;
  
  const sourceSection = draggedElement.closest('.section-row').getAttribute('data-section');
  const targetSection = this.closest('.section-row').getAttribute('data-section');
  
  reorderShortcuts(sourceSection, targetSection, sourceIndex, targetIndex);
}

async function reorderShortcuts(sourceSection, targetSection, sourceIndex, targetIndex) {
  try {
    const response = await fetch(LINKS_FILENAME);
    if (!response.ok) throw new Error('Failed to fetch');
    const data = await response.json();
    
    // Get the shortcut to move
    const shortcut = data[sourceSection][sourceIndex];
    
    // Remove from source
    data[sourceSection].splice(sourceIndex, 1);
    
    // Add to target
    if (sourceSection === targetSection) {
      data[targetSection].splice(targetIndex, 0, shortcut);
    } else {
      data[targetSection].splice(targetIndex, 0, shortcut);
    }
    
    // Save the updated data (this will likely fail in file:// mode)
    try {
      await fetch(LINKS_FILENAME, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(data, null, 2)
      });
    } catch (saveError) {
      console.warn(`Could not save changes to ${LINKS_FILENAME} (expected in file:// mode):`, saveError);
    }
    
    // Refresh the UI
    refreshUI();
  } catch (error) {
    console.error('Error updating shortcuts:', error);
    alert('Could not reorder shortcuts. This feature requires a web server.');
  }
}

    function deleteShortcut(button) {
      const shortcutWrapper = button.closest('.shortcut-wrapper');
      const row = shortcutWrapper.parentElement;
      shortcutWrapper.remove();
      saveChanges();
    }

    function editShortcut(button) {
    const shortcutWrapper = button.closest('.shortcut-wrapper');
    const shortcut = shortcutWrapper.querySelector('.shortcut, .hidden-shortcut');
    currentEditingShortcut = shortcut;
    const modal = document.getElementById('editModal');
    const titleInput = document.getElementById('editTitle');
    const urlInput = document.getElementById('editUrl');
    const imageInput = document.getElementById('editImage');
    const hiddenInput = document.getElementById('editHidden');

    // Set modal title for editing
    document.getElementById('modalTitle').textContent = 'Edit Shortcut';
    
    // Show URL section with fetch button for editing
    document.getElementById('urlInputSection').style.display = 'block';
    document.getElementById('detailsSection').style.display = 'block';
    document.getElementById('fetchButton').style.display = 'inline-block';
    document.getElementById('saveButton').style.display = 'inline-block';

    titleInput.value = currentEditingShortcut.querySelector('.title').textContent;
    urlInput.value = currentEditingShortcut.href;
    imageInput.value = currentEditingShortcut.querySelector('.shortcutimg').src;
    
    // Check if this shortcut is marked as hidden in the data
    const sectionName = currentEditingShortcut.closest('.section-row').getAttribute('data-section');
    const shortcutIndex = parseInt(currentEditingShortcut.getAttribute('data-index'));
    
    // We'll need to fetch the current data to check hidden status
    fetch(LINKS_FILENAME)
        .then(response => {
            if (!response.ok) throw new Error('Failed to fetch');
            return response.json();
        })
        .then(data => {
            hiddenInput.checked = data[sectionName][shortcutIndex]?.hidden || false;
        })
        .catch(error => {
            console.warn('Could not fetch links data for edit modal:', error);
            hiddenInput.checked = false;
        });

    modal.style.display = 'flex';
}

    function closeModal() {
      const modal = document.getElementById('editModal');
      modal.style.display = 'none';
      
      // Reset modal state
      document.getElementById('urlInputSection').style.display = 'block';
      document.getElementById('detailsSection').style.display = 'none';
      document.getElementById('fetchingIndicator').style.display = 'none';
      document.getElementById('fetchButton').style.display = 'none';
      document.getElementById('saveButton').style.display = 'none';
      
      // Clear inputs
      document.getElementById('editUrl').value = '';
      document.getElementById('editTitle').value = '';
      document.getElementById('editImage').value = '';
      document.getElementById('editHidden').checked = false;
      
      currentEditingShortcut = null;
    }

    async function fetchSiteInfo() {
      const urlInput = document.getElementById('editUrl');
      const titleInput = document.getElementById('editTitle');
      const imageInput = document.getElementById('editImage');
      const fetchingIndicator = document.getElementById('fetchingIndicator');
      const fetchButton = document.getElementById('fetchButton');
      const saveButton = document.getElementById('saveButton');
      const detailsSection = document.getElementById('detailsSection');
      
      let url = urlInput.value.trim();
      
      if (!url) {
        alert('Please enter a URL');
        return;
      }
      
      // Add https:// if no protocol is specified
      if (!url.match(/^https?:\/\//)) {
        url = 'https://' + url;
        urlInput.value = url;
      }
      
      // Validate URL
      try {
        new URL(url);
      } catch (e) {
        alert('Please enter a valid URL');
        return;
      }
      
      fetchingIndicator.style.display = 'block';
      fetchButton.style.display = 'none';
      
      try {
        // Extract domain for favicon
        const domain = new URL(url).hostname;
        
        // Try to fetch the page title
        let title = domain;
        try {
          // This is a simple approach - in a real implementation you might want to use a service
          // For now, we'll use the domain as the title and let users edit it
          title = domain.replace('www.', '').split('.')[0];
          title = title.charAt(0).toUpperCase() + title.slice(1);
        } catch (titleError) {
          console.warn('Could not fetch page title:', titleError);
        }
        
        // Generate favicon URL
        const faviconUrl = `https://www.google.com/s2/favicons?domain=${domain}&sz=64`;
        
        // Populate the form
        titleInput.value = title;
        imageInput.value = faviconUrl;
        
        // Show details section
        detailsSection.style.display = 'block';
        saveButton.style.display = 'inline-block';
        
      } catch (error) {
        console.error('Error fetching site info:', error);
        alert('Could not fetch site information. Please fill in the details manually.');
        
        // Show details section anyway so user can manually enter info
        detailsSection.style.display = 'block';
        saveButton.style.display = 'inline-block';
      }
      
      fetchingIndicator.style.display = 'none';
    }

    async function saveShortcut() {
      const title = document.getElementById('editTitle').value.trim();
      const url = document.getElementById('editUrl').value.trim();
      const image = document.getElementById('editImage').value.trim();
      const hidden = document.getElementById('editHidden').checked;
      
      if (!title || !url || !image) {
        alert('Please fill in all fields');
        return;
      }
      
      try {
        // Load current data
        const response = await fetch(LINKS_FILENAME);
        if (!response.ok) throw new Error('Failed to fetch current data');
        const data = await response.json();
        
        if (currentEditingShortcut) {
          // Editing existing shortcut
          const sectionName = currentEditingShortcut.closest('.section-row').getAttribute('data-section');
          const shortcutIndex = parseInt(currentEditingShortcut.getAttribute('data-index'));
          
          // Update the data
          data[sectionName][shortcutIndex] = { title, url, image, hidden };
          
          // Update the UI element
          currentEditingShortcut.href = url;
          currentEditingShortcut.querySelector('.title').textContent = title;
          currentEditingShortcut.querySelector('.shortcutimg').src = image;
          currentEditingShortcut.style.setProperty('--shortcut-background', `url('${image}')`);
          currentEditingShortcut.setAttribute('data-hidden', hidden);
        } else {
          // Adding new shortcut - we need to know which section
          const sectionName = currentEditingSectionName; // We'll need to store this
          if (!sectionName || !data[sectionName]) {
            alert('Error: Could not determine which section to add to');
            return;
          }
          
          // Add to data
          data[sectionName].push({ title, url, image, hidden });
        }
        
        // Try to save the data
        try {
          const saveResponse = await fetch(LINKS_FILENAME, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(data, null, 2)
          });
          
          if (!saveResponse.ok) throw new Error('Save failed');
          
          console.log('Successfully saved shortcut');
          
          // Refresh the UI to show changes
          refreshUI();
          
        } catch (saveError) {
          console.warn('Could not save to file (expected in static hosting):', saveError);
          
          // For now, just update the UI and inform the user
          if (!currentEditingShortcut) {
            // For new shortcuts, refresh UI to show the change temporarily
            refreshUI();
          }
          
          alert('Shortcut updated in the interface, but could not be saved to file. Changes will be lost on page reload. To persist changes, you need a server that supports file writing.');
        }
        
      } catch (error) {
        console.error('Error saving shortcut:', error);
        alert('Error saving shortcut: ' + error.message);
      }
      
      closeModal();
    }

    function addShortcut(sectionName) {
      currentEditingShortcut = null;
      currentEditingSectionName = sectionName;
      
      // Set modal title for adding
      document.getElementById('modalTitle').textContent = `Add Shortcut to ${sectionName}`;
      
      // Reset modal state
      document.getElementById('urlInputSection').style.display = 'block';
      document.getElementById('detailsSection').style.display = 'none';
      document.getElementById('fetchingIndicator').style.display = 'none';
      document.getElementById('fetchButton').style.display = 'inline-block';
      document.getElementById('saveButton').style.display = 'none';
      
      // Clear inputs
      document.getElementById('editUrl').value = '';
      document.getElementById('editTitle').value = '';
      document.getElementById('editImage').value = '';
      document.getElementById('editHidden').checked = false;
      
      document.getElementById('editModal').style.display = 'flex';
      
      // Focus on URL input
      setTimeout(() => {
        document.getElementById('editUrl').focus();
      }, 100);
    }

    function saveChanges() {
      // Implement the logic to save changes to links.json
      const newData = {};
      const sections = document.getElementById('container').children;
      
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        const sectionTitle = section.querySelector('.section-title').textContent;
        const shortcuts = section.querySelectorAll('.shortcut');
        newData[sectionTitle] = Array.from(shortcuts).map(s => ({
          title: s.querySelector('.title').textContent,
          url: s.href,
          image: s.querySelector('.shortcutimg').src,
          hidden: s.getAttribute('data-hidden') === 'true'
        }));
      }

      // You'll need to implement server-side saving here
      console.log(`Save this data to ${LINKS_FILENAME}:`, newData);
    }

    function toggleMode() {
    const body = document.body;
    const toggleButton = document.querySelector('.toggle');
    body.classList.toggle('dark-mode');

    // Update display settings based on theme
    const brightnessSlider = document.getElementById('brightnessSlider');
    const contrastSlider = document.getElementById('contrastSlider');
    const overlay = document.querySelector('.background-overlay');

    if (body.classList.contains('dark-mode')) {
        // Dark mode settings
        brightnessSlider.value = 40; // 0.4 * 100
        contrastSlider.value = 100; // 1.0 * 100
        overlay.style.filter = `blur(${document.getElementById('blurSlider').value}px) brightness(0.8) contrast(1)`;
    } else {
        // Light mode settings
        brightnessSlider.value = 80; // 0.8 * 100
        contrastSlider.value = 100; // 1.0 * 100
        overlay.style.filter = `blur(${document.getElementById('blurSlider').value}px) brightness(0.4) contrast(1)`;
    }

    // Update display values
    document.getElementById('brightnessValue').textContent = (brightnessSlider.value / 100).toFixed(2);
    document.getElementById('contrastValue').textContent = (contrastSlider.value / 100).toFixed(2);

    // Update other elements
    const shortcutImages = document.querySelectorAll('.shortcutimg');
    shortcutImages.forEach(img => {
        img.classList.toggle('dark-mode');
    });

    const shortcuts = document.querySelectorAll('.shortcut, .hidden-shortcut');
    shortcuts.forEach(shortcut => {
        shortcut.classList.toggle('dark-mode');
    });

    const backgroundimg = document.querySelectorAll('.background-overlay');
    backgroundimg.forEach(backgroundimg => {
        backgroundimg.classList.toggle('dark-mode');
    });

    const toggle = document.querySelectorAll('.toggle');
    toggle.forEach(toggleicon => {
        toggleicon.classList.toggle('dark-mode');
    });

    const sectionTitles = document.querySelectorAll('.section-title');
    sectionTitles.forEach(title => {
        title.classList.toggle('dark-mode');
    });

    // Save settings if persistence is enabled
    if (localStorage.getItem('persistSettings') === 'true') {
        saveConfig();
    }
}

    function toggleAllHidden() {
      // Check if we're in edit mode - this feature is only for normal mode
      if (editMode) {
        return;
      }
      
      const toggleButton = document.getElementById('toggleHiddenButton');
      const chevronButtons = document.querySelectorAll('.chevron-button');
      const hiddenContainers = document.querySelectorAll('.hidden-shortcuts-container');
      
      // Check current state - if any hidden container is expanded, we'll collapse all
      // If all are collapsed, we'll expand all
      const anyExpanded = Array.from(hiddenContainers).some(container => 
        container.classList.contains('expanded')
      );
      
      if (anyExpanded) {
        // Hide all hidden shortcuts
        chevronButtons.forEach(chevron => {
          const hiddenContainer = chevron.closest('.section-row').querySelector('.hidden-shortcuts-container');
          if (hiddenContainer && hiddenContainer.classList.contains('expanded')) {
            chevron.classList.remove('expanded');
            hiddenContainer.classList.remove('expanded');
            chevron.setAttribute('aria-expanded', 'false');
            chevron.setAttribute('aria-label', 'Show hidden shortcuts');
          }
        });
        toggleButton.textContent = 'Show all hidden';
      } else {
        // Show all hidden shortcuts
        chevronButtons.forEach(chevron => {
          const hiddenContainer = chevron.closest('.section-row').querySelector('.hidden-shortcuts-container');
          if (hiddenContainer && !hiddenContainer.classList.contains('expanded')) {
            chevron.classList.add('expanded');
            hiddenContainer.classList.add('expanded');
            chevron.setAttribute('aria-expanded', 'true');
            chevron.setAttribute('aria-label', 'Hide hidden shortcuts');
          }
        });
        toggleButton.textContent = 'Hide all hidden';
      }
    }

    function updateToggleAllButtonText() {
      const toggleButton = document.getElementById('toggleHiddenButton');
      if (!toggleButton) return;
      
      const hiddenContainers = document.querySelectorAll('.hidden-shortcuts-container');
      if (hiddenContainers.length === 0) {
        toggleButton.textContent = 'Show all hidden';
        return;
      }
      
      const anyExpanded = Array.from(hiddenContainers).some(container => 
        container.classList.contains('expanded')
      );
      
      const allExpanded = Array.from(hiddenContainers).every(container => 
        container.classList.contains('expanded')
      );
      
      if (allExpanded) {
        toggleButton.textContent = 'Hide all hidden';
      } else if (anyExpanded) {
        toggleButton.textContent = 'Show all hidden';
      } else {
        toggleButton.textContent = 'Show all hidden';
      }
    }

    loadLinks();

    // Initialize URL input event listener for add shortcut functionality
    document.getElementById('editUrl').addEventListener('input', function() {
      const url = this.value.trim();
      const fetchButton = document.getElementById('fetchButton');
      
      if (url && !currentEditingShortcut) {
        fetchButton.style.display = 'inline-block';
      } else if (!currentEditingShortcut) {
        fetchButton.style.display = 'none';
      }
    });
    
    // Allow Enter key to trigger fetch when in URL input
    document.getElementById('editUrl').addEventListener('keypress', function(e) {
      if (e.key === 'Enter' && !currentEditingShortcut && this.value.trim()) {
        fetchSiteInfo();
      }
    });

    // Add the shortcut size control handlers
    const shortcutSizeSlider = document.getElementById('shortcutSizeSlider');
    const gapSizeSlider = document.getElementById('gapSizeSlider');
    const maxColumnsSelect = document.getElementById('maxColumnsSelect');

    function updateShortcutStyles() {
        const shortcutSize = shortcutSizeSlider.value;
        const gapSize = gapSizeSlider.value;
        const maxColumns = maxColumnsSelect.value;

        document.getElementById('shortcutSizeValue').textContent = shortcutSize;
        document.getElementById('gapSizeValue').textContent = gapSize;

        // Update CSS custom properties
        document.documentElement.style.setProperty('--shortcut-size', `${shortcutSize}px`);
        document.documentElement.style.setProperty('--gap-size', `${gapSize}px`);

        const style = document.createElement('style');
        style.textContent = `
            .shortcut {
                width: ${shortcutSize}px !important;
                height: ${shortcutSize}px !important;
            }
            .section-row {
                gap: ${gapSize}px ${gapSize}px !important;
                ${maxColumns === 'unlimited' 
                    ? `display: flex !important; flex-flow: row wrap !important;` 
                    : `display: grid !important; grid-template-columns: repeat(${maxColumns}, ${shortcutSize}px) !important;`
                }
            }
        `;

        // Remove any previous dynamic styles
        const existingStyle = document.getElementById('dynamic-shortcut-styles');
        if (existingStyle) {
            existingStyle.remove();
        }
        style.id = 'dynamic-shortcut-styles';
        document.head.appendChild(style);

        if (localStorage.getItem('persistSettings') === 'true') {
            saveConfig();
        }
    }

    shortcutSizeSlider.addEventListener('input', updateShortcutStyles);
    gapSizeSlider.addEventListener('input', updateShortcutStyles);
    maxColumnsSelect.addEventListener('change', updateShortcutStyles);

    function saveConfig() {
        const config = {
            darkMode: document.body.classList.contains('dark-mode'),
            backgroundImage: document.querySelector('.background-overlay').style.backgroundImage,
            timestamp: new Date().toISOString(),
            linksData: null,
            shortcutSize: shortcutSizeSlider.value,
            gapSize: gapSizeSlider.value,
            maxColumns: maxColumnsSelect.value,
            autoFitEnabled: document.getElementById('autoFitEnabled').checked,
            shadowSize: document.getElementById('shadowSlider').value,
        };
        
        // Save the links data
        fetch(LINKS_FILENAME)
            .then(response => response.json())
            .then(data => {
                config.linksData = data;
                localStorage.setItem('siteConfig', JSON.stringify(config));
            });
    }

    async function loadConfig() {
        const savedConfig = localStorage.getItem('siteConfig');
        if (savedConfig) {
            const config = JSON.parse(savedConfig);
            
            // Apply dark mode
            if (config.darkMode !== document.body.classList.contains('dark-mode')) {
                toggleMode();
            }
            
            // Apply background image if different
            if (config.backgroundImage) {
                document.querySelector('.background-overlay').style.backgroundImage = config.backgroundImage;
            }
            
            // Load links data
            if (config.linksData) {
                const container = document.getElementById('container');
                container.innerHTML = ''; // Clear existing content
                Object.entries(config.linksData).forEach(([sectionName, links]) => {
                    // Create a section wrapper
                    const sectionWrapper = document.createElement('div');
                    sectionWrapper.className = 'section-wrapper';
                    sectionWrapper.style.cssText = 'display: flex; flex-direction: column; min-width: 300px; flex: 0 1 auto;';

                    const sectionTitle = document.createElement('h2');
                    sectionTitle.className = 'section-title';
                    sectionTitle.textContent = sectionName;
                    sectionWrapper.appendChild(sectionTitle);
        
                    const row = document.createElement('div');
                    row.className = 'section-row';
        
                    links.forEach((item) => {
                        // Skip hidden shortcuts for main display
                        if (item.hidden) return;
                        
                        const shortDiv = document.createElement('a');
                        shortDiv.href = item.url;
                        shortDiv.target = '_blank';
                        shortDiv.className = 'shortcut';
                        shortDiv.style.setProperty('--shortcut-background', `url('${item.image}')`);
                        shortDiv.setAttribute('title', item.title);
        
                        shortDiv.innerHTML = `
                            <img src="${item.image}" class="shortcutimg" alt="${item.title}" />
                            <div class="title">${item.title}</div>
                        `;
                        row.appendChild(shortDiv);
                    });
                    
                    // Handle hidden shortcuts
                    const hiddenShortcuts = links.filter(item => item.hidden);
                    if (hiddenShortcuts.length > 0) {
                        // Create hidden shortcuts container for inline expansion
                        const hiddenContainer = document.createElement('div');
                        hiddenContainer.className = 'hidden-shortcuts-container';
                        
                        hiddenShortcuts.forEach(item => {
                            const hiddenShortcut = document.createElement('a');
                            hiddenShortcut.href = item.url;
                            hiddenShortcut.target = '_blank';
                            hiddenShortcut.className = 'hidden-shortcut';
                            hiddenShortcut.style.setProperty('--shortcut-background', `url("${item.image}")`);
                            
                            hiddenShortcut.innerHTML = `
                                <img src="${item.image}" alt="${item.title}" class="shortcutimg" />
                                <div class="title">${item.title}</div>
                            `;
                            hiddenContainer.appendChild(hiddenShortcut);
                        });
                        
                        // Create chevron button
                        const chevronButton = document.createElement('div');
                        chevronButton.className = 'chevron-button';
                        chevronButton.innerHTML = '<span class="chevron-icon"></span>';
                        chevronButton.setAttribute('role', 'button');
                        chevronButton.setAttribute('tabindex', '0');
                        chevronButton.setAttribute('aria-expanded', 'false');
                        chevronButton.setAttribute('aria-label', 'Show hidden shortcuts');
                        
                        chevronButton.addEventListener('click', () => {
                            const isExpanded = chevronButton.classList.toggle('expanded');
                            hiddenContainer.classList.toggle('expanded');
                            chevronButton.setAttribute('aria-expanded', isExpanded);
                            chevronButton.setAttribute('aria-label', isExpanded ? 'Hide hidden shortcuts' : 'Show hidden shortcuts');
                            
                            // Update the toggle all button text based on current state
                            updateToggleAllButtonText();
                        });
                        
                        // Add hidden container and chevron to row
                        row.appendChild(hiddenContainer);
                        row.appendChild(chevronButton);
                    }
                    sectionWrapper.appendChild(row);
                    container.appendChild(sectionWrapper);
                });
            }

            // Apply shortcut size settings
            if (config.shortcutSize) shortcutSizeSlider.value = config.shortcutSize;
            if (config.gapSize) gapSizeSlider.value = config.gapSize;
            if (config.maxColumns) maxColumnsSelect.value = config.maxColumns;
            if (config.autoFitEnabled !== undefined) {
                document.getElementById('autoFitEnabled').checked = config.autoFitEnabled;
            }
            if (config.shadowSize) {
                document.getElementById('shadowSlider').value = config.shadowSize;
                document.documentElement.style.setProperty('--shadow-size', `${config.shadowSize}px`);
            }
            updateShortcutStyles();
        }
    }
    
    function exportConfig() {
        fetch(LINKS_FILENAME)
            .then(response => response.json())
            .then(data => {
                const config = {
                    darkMode: document.body.classList.contains('dark-mode'),
                    backgroundImage: document.querySelector('.background-overlay').style.backgroundImage,
                    timestamp: new Date().toISOString(),
                    linksData: data,
                    shortcutSize: shortcutSizeSlider.value,
                    gapSize: gapSizeSlider.value,
                    maxColumns: maxColumnsSelect.value
                };
                
                const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'site-config.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
    }
    
    function importConfig() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = (e) => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = async (event) => {
                try {
                    const config = JSON.parse(event.target.result);
                    if (config.darkMode !== document.body.classList.contains('dark-mode')) {
                        toggleMode();
                    }
                    if (config.linksData) {
                        const container = document.getElementById('container');
                        container.innerHTML = '';
                        await loadLinks(config.linksData);
                    }
                    if (config.shortcutSize) shortcutSizeSlider.value = config.shortcutSize;
                    if (config.gapSize) gapSizeSlider.value = config.gapSize;
                    if (config.maxColumns) maxColumnsSelect.value = config.maxColumns;
                    updateShortcutStyles();
                    saveConfig();
                } catch (err) {
                    alert('Invalid configuration file');
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function toggleMenu() {
        const burgerButton = document.querySelector('.burger-button');
        const menuContent = document.querySelector('.menu-content');
        burgerButton.classList.toggle('active');
        menuContent.classList.toggle('active');
    }

    // Close menu when clicking outside
    document.addEventListener('click', (e) => {
        const burgerMenu = document.querySelector('.burger-menu');
        const burgerButton = document.querySelector('.burger-button');
        const menuContent = document.querySelector('.menu-content');
        
        if (!burgerMenu.contains(e.target) && menuContent.classList.contains('active')) {
            burgerButton.classList.remove('active');
            menuContent.classList.remove('active');
        }
    });

    function toggleHiddenShortcuts(chevronButton) {
    const sectionRow = chevronButton.closest('.section-row');
    const hiddenContainer = sectionRow.querySelector('.hidden-shortcuts-container');
    const chevronIcon = chevronButton.querySelector('.chevron-icon');
    
    if (hiddenContainer) {
        const isExpanded = hiddenContainer.classList.contains('expanded');
        
        if (isExpanded) {
            // Collapse
            hiddenContainer.classList.remove('expanded');
            chevronButton.classList.remove('expanded');
            chevronButton.setAttribute('aria-expanded', 'false');
            chevronButton.setAttribute('aria-label', 'Show hidden shortcuts');
        } else {
            // Expand - calculate optimal max-width
            const hiddenShortcuts = hiddenContainer.querySelectorAll('.hidden-shortcut');
            const shortcutSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--shortcut-size'));
            const gapSize = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap-size'));
            const optimalWidth = (hiddenShortcuts.length * shortcutSize) + ((hiddenShortcuts.length - 1) * gapSize);
            
            hiddenContainer.style.maxWidth = `${optimalWidth}px`;
            hiddenContainer.classList.add('expanded');
            chevronButton.classList.add('expanded');
            chevronButton.setAttribute('aria-expanded', 'true');
            chevronButton.setAttribute('aria-label', 'Hide hidden shortcuts');
        }
    }
}

// Add keyboard support for chevron buttons
document.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' || e.key === ' ') {
        const chevronButton = e.target.closest('.chevron-button');
        if (chevronButton) {
            e.preventDefault();
            toggleHiddenShortcuts(chevronButton);
        }
    }
});

    function requestStoragePermission(event) {
        event.preventDefault();
        if (confirm("Would you like your browser to save your settings permanently?")) {
            localStorage.setItem('persistSettings', 'true');
            saveConfig();
            alert('Your settings will now be saved automatically!');
        } else {
            localStorage.removeItem('persistSettings');
            localStorage.removeItem('siteConfig');
            alert('Settings will not be saved between sessions.');
        }
    }

    if (localStorage.getItem('persistSettings') === 'true') {
        saveConfig();
    }

    function setBackgroundFromUrl() {
        const url = document.getElementById('bgUrlInput').value;
        if (url) {
            document.querySelector('.background-overlay').style.backgroundImage = `url("${url}")`;
            if (localStorage.getItem('persistSettings') === 'true') {
                saveConfig();
            }
        }
    }

    // Handle file uploads
    document.getElementById('bgFileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                document.querySelector('.background-overlay').style.backgroundImage = `url("${e.target.result}")`;
                if (localStorage.getItem('persistSettings') === 'true') {
                    saveConfig();
                }
            };
            reader.readAsDataURL(file);
        }
    });

    function toggleDisplaySettings() {
        const settings = document.getElementById('displaySettings');
        settings.style.display = settings.style.display === 'none' ? 'block' : 'none';
    }

    // Initialize sliders
    const updateBackgroundFilter = () => {
        const blur = document.getElementById('blurSlider').value;
        const brightness = document.getElementById('brightnessSlider').value / 100;
        const contrast = document.getElementById('contrastSlider').value / 100;
        
        document.getElementById('blurValue').textContent = blur;
        document.getElementById('brightnessValue').textContent = brightness.toFixed(2);
        document.getElementById('contrastValue').textContent = contrast.toFixed(2);
        
        const overlay = document.querySelector('.background-overlay');
        overlay.style.filter = `blur(${blur}px) brightness(${brightness}) contrast(${contrast})`;
    };

   

    const updateShadow = () => {
        const shadow = document.getElementById('shadowSlider').value;
        document.getElementById('shadowValue').textContent = shadow;
        document.documentElement.style.setProperty('--shadow-size', `${shadow}px`);
        
        if (localStorage.getItem('persistSettings') === 'true') {
            saveConfig();
        }
    };

    // Update the event listeners
    ['blurSlider', 'brightnessSlider', 'contrastSlider'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateBackgroundFilter);
    });

    document.getElementById('shadowSlider').addEventListener('input', updateShadow);

    function autoAdjustGap() {
    // Get viewport width
    const viewportWidth = window.innerWidth - 60; // Subtract 60px for margins
    
    // Get shortcut size and max columns setting
    const shortcutSize = parseInt(document.getElementById('shortcutSizeSlider').value);
    const maxColumns = document.getElementById('maxColumnsSelect').value;
    
    // Find section with most shortcuts
    const sections = document.querySelectorAll('.section-row');
    let maxShortcuts = 0;
    
    sections.forEach(section => {
        const shortcutCount = section.querySelectorAll('.shortcut').length;
        maxShortcuts = Math.max(maxShortcuts, shortcutCount);
    });
    
    // Calculate optimal gap size based on max columns setting
    const totalWidth = viewportWidth;
    const possibleColumns = Math.floor(totalWidth / shortcutSize);
    
    // Determine number of columns to use
    let neededColumns;
    if (maxColumns === 'unlimited') {
        neededColumns = Math.min(possibleColumns, maxShortcuts);
    } else {
        neededColumns = Math.min(possibleColumns, maxShortcuts, parseInt(maxColumns));
    }
    
    const totalGapSpace = totalWidth - (neededColumns * shortcutSize);
    const gaps = neededColumns - 1;
    let optimalGap = gaps > 0 ? Math.floor(totalGapSpace / gaps) : 0;
    
    // Ensure gap size is within slider limits
    optimalGap = Math.max(0, Math.min(120, optimalGap));
    
    // Update gap size slider and apply changes
    const gapSizeSlider = document.getElementById('gapSizeSlider');
    gapSizeSlider.value = optimalGap;
    document.getElementById('gapSizeValue').textContent = optimalGap;
    
    // Update styles
    updateShortcutStyles();
}

// Debounce function to limit how often the resize handler fires
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Add window resize listener with debouncing
window.addEventListener('resize', debounce(() => {
    const maxColumns = document.getElementById('maxColumnsSelect').value;
    const autoFitEnabled = document.getElementById('autoFitEnabled').checked;
    
    if (maxColumns !== '1' && autoFitEnabled) {
        autoAdjustShortcutSize();
    }
}, 250)); // Wait 250ms after resize ends before executing

// Add checkbox event listener after other initialization code
document.getElementById('autoFitEnabled').addEventListener('change', function(e) {
    if (e.target.checked) {
        autoAdjustShortcutSize();
    }
    if (localStorage.getItem('persistSettings') === 'true') {
        saveConfig();
    }
});

function autoAdjustShortcutSize() {
    const viewportWidth = window.innerWidth;
    const shortcutSizeSlider = document.getElementById('shortcutSizeSlider');
    const gapSizeSlider = document.getElementById('gapSizeSlider');
    
    // Shortcut size scaling
    // - Base size: 64px at 400px viewport
    // - Increases by 8px every 50px of viewport width
    // - Clamp between 64px and 184px
    const baseShortcutSize = 64;
    const shortcutGrowthRate = 4 / 50; // 8px increase per 50px of width
    const shortcutSize = Math.round(baseShortcutSize + (viewportWidth - 400) * shortcutGrowthRate);
    const newShortcutSize = Math.max(64, Math.min(184, shortcutSize));

    // Gap size scaling
    // - Base size: 5px at 400px viewport
    // - Increases by 2px every 50px of viewport width
    // - Clamp between 5px and 40px
    const baseGapSize = 5;
    const gapGrowthRate = 2 / 50; // 2px increase per 50px of width
    const gapSize = Math.round(baseGapSize + (viewportWidth - 400) * gapGrowthRate);
    const newGapSize = Math.max(5, Math.min(40, gapSize));

    // Update shortcut size slider and value
    shortcutSizeSlider.value = newShortcutSize;
    document.getElementById('shortcutSizeValue').textContent = newShortcutSize;
    
    // Update gap size slider and value
    gapSizeSlider.value = newGapSize;
    document.getElementById('gapSizeValue').textContent = newGapSize;
    
    // Update styles
    updateShortcutStyles();
}

// Replace the existing resize listener
window.addEventListener('resize', debounce(() => {
    const maxColumns = document.getElementById('maxColumnsSelect').value;
    const autoFitEnabled = document.getElementById('autoFitEnabled').checked;
    
    if (maxColumns !== '1' && autoFitEnabled) {
        autoAdjustShortcutSize();
    }
}, 250));

// Update the checkbox event listener to respect auto-fit setting
document.getElementById('autoFitEnabled').addEventListener('change', function(e) {
    if (e.target.checked) {
        autoAdjustShortcutSize();
    }
    if (localStorage.getItem('persistSettings') === 'true') {
        saveConfig();
    }
});

function toggleAllHidden() {
      // Check if we're in edit mode - this feature is only for normal mode
      if (editMode) {
        return;
      }
      
      const toggleButton = document.getElementById('toggleHiddenButton');
      const chevronButtons = document.querySelectorAll('.chevron-button');
      const hiddenContainers = document.querySelectorAll('.hidden-shortcuts-container');
      
      // Check current state - if any hidden container is expanded, we'll collapse all
      // If all are collapsed, we'll expand all
      const anyExpanded = Array.from(hiddenContainers).some(container => 
        container.classList.contains('expanded')
      );
      
      if (anyExpanded) {
        // Hide all hidden shortcuts
        chevronButtons.forEach(chevron => {
          const hiddenContainer = chevron.closest('.section-row').querySelector('.hidden-shortcuts-container');
          if (hiddenContainer && hiddenContainer.classList.contains('expanded')) {
            chevron.classList.remove('expanded');
            hiddenContainer.classList.remove('expanded');
            chevron.setAttribute('aria-expanded', 'false');
            chevron.setAttribute('aria-label', 'Show hidden shortcuts');
          }
        });
        toggleButton.textContent = 'Show all hidden';
      } else {
        // Show all hidden shortcuts
        chevronButtons.forEach(chevron => {
          const hiddenContainer = chevron.closest('.section-row').querySelector('.hidden-shortcuts-container');
          if (hiddenContainer && !hiddenContainer.classList.contains('expanded')) {
            chevron.classList.add('expanded');
            hiddenContainer.classList.add('expanded');
            chevron.setAttribute('aria-expanded', 'true');
            chevron.setAttribute('aria-label', 'Hide hidden shortcuts');
          }
        });
        toggleButton.textContent = 'Hide all hidden';
      }
    }
  </script>
</body>
</html>
